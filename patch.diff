*** Begin Patch
*** Update File: backend/src/index.ts
@@
-app.get(
-  "/livechat/inboxes/:inboxId/agents",
-  requireAuth,
-  async (req: any, res) => {
+app.get(
+  "/livechat/inboxes/:inboxId/agents",
+  requireAuth,
+  async (req: any, res) => {
@@
-  },
-);
-
-// Definir responsável (assignee) do contato do chat, validando com inbox_users
+  },
+);
+
+async function ensureInboxWriteAccess(chat: any, authUserId: string) {
+  let actingUserLocalId: string | null = null;
+  try {
+    const { data: urow } = await supabaseAdmin
+      .from("users")
+      .select("id")
+      .eq("user_id", authUserId)
+      .maybeSingle();
+    actingUserLocalId = (urow as any)?.id || null;
+  } catch {}
+  if (!actingUserLocalId) return;
+
+  const { data: linkAct } = await supabaseAdmin
+    .from("inbox_users")
+    .select("can_write, can_manage")
+    .eq("inbox_id", (chat as any).inbox_id)
+    .eq("user_id", actingUserLocalId)
+    .maybeSingle();
+  if (!linkAct || (!linkAct.can_write && !linkAct.can_manage)) {
+    const error: any = new Error("Sem permissão para operar nesta inbox");
+    error.status = 403;
+    throw error;
+  }
+}
+
+async function resolveChatKanbanContext(chatId: string) {
+  const { data: chat, error: errChat } = await supabaseAdmin
+    .from("chats")
+    .select("id, inbox_id, customer_id")
+    .eq("id", chatId)
+    .maybeSingle();
+  if (errChat) {
+    const error: any = new Error(errChat.message);
+    error.status = 500;
+    throw error;
+  }
+  if (!chat) {
+    const error: any = new Error("Chat não encontrado");
+    error.status = 404;
+    throw error;
+  }
+
+  const customerId = (chat as any).customer_id as string | null;
+  const leadIds = new Set<string>();
+
+  if (customerId) {
+    try {
+      const { data: customerRow } = await supabaseAdmin
+        .from("customers")
+        .select("lead_id")
+        .eq("id", customerId)
+        .maybeSingle();
+      if (customerRow?.lead_id)
+        leadIds.add(String((customerRow as any).lead_id));
+    } catch {}
+    try {
+      const { data: leadsByCustomer } = await supabaseAdmin
+        .from("leads")
+        .select("id")
+        .eq("customer_id", customerId);
+      for (const row of leadsByCustomer || []) {
+        if ((row as any)?.id) leadIds.add(String((row as any).id));
+      }
+    } catch {}
+    try {
+      const { data: leadRow } = await supabaseAdmin
+        .from("leads")
+        .select("id")
+        .eq("id", customerId)
+        .maybeSingle();
+      if (leadRow?.id) leadIds.add(String((leadRow as any).id));
+    } catch {}
+  }
+
+  const leadIdsArray = Array.from(leadIds);
+  let cards: any[] = [];
+  if (leadIdsArray.length > 0) {
+    try {
+      const { data: cardRows } = await supabaseAdmin
+        .from("kanban_cards")
+        .select(
+          "id, kanban_board_id, kanban_column_id, owner_user_id, notes, email, contact, title, value_numeric, source, lead_id",
+        )
+        .in("lead_id", leadIdsArray);
+      cards = cardRows || [];
+    } catch {}
+  }
+
+  return { chat, customerId, leadIds: leadIdsArray, cards };
+}
+
+function mapKanbanCardForResponse(card: any) {
+  return {
+    id: (card as any).id,
+    title: (card as any).title || null,
+    value: Number((card as any).value_numeric || 0),
+    stage: (card as any).kanban_column_id || null,
+    owner: (card as any).owner_user_id || null,
+    source: (card as any).source || null,
+    notes: (card as any).notes || null,
+    email: (card as any).email || null,
+    contact: (card as any).contact || null,
+    leadId: (card as any).lead_id || null,
+    boardId: (card as any).kanban_board_id || null,
+  };
+}
+
+app.get("/livechat/chats/:id/kanban", requireAuth, async (req: any, res) => {
+  const { id } = req.params as { id: string };
+  try {
+    const context = await resolveChatKanbanContext(id);
+
+    let stageId: string | null = null;
+    let noteValue: string | null = null;
+    if (context.cards.length > 0) {
+      const firstCard = context.cards[0] as any;
+      stageId = firstCard?.kanban_column_id || null;
+      noteValue = firstCard?.notes || null;
+    }
+
+    if ((!stageId || !noteValue) && context.leadIds.length > 0) {
+      try {
+        const { data: leadRow } = await supabaseAdmin
+          .from("leads")
+          .select("id, kanban_column_id, notes")
+          .in("id", context.leadIds)
+          .limit(1)
+          .maybeSingle();
+        if (leadRow) {
+          if (!stageId) stageId = (leadRow as any).kanban_column_id || null;
+          if (!noteValue) noteValue = (leadRow as any).notes || null;
+        }
+      } catch {}
+    }
+
+    return res.json({
+      ok: true,
+      stage_id: stageId || null,
+      note: noteValue || null,
+      cards: context.cards.map(mapKanbanCardForResponse),
+      lead_ids: context.leadIds,
+    });
+  } catch (e: any) {
+    const status = e?.status || 500;
+    return res
+      .status(status)
+      .json({ error: e?.message || "Erro ao carregar dados do kanban" });
+  }
+});
+
+app.patch("/livechat/chats/:id/stage", requireAuth, async (req: any, res) => {
+  const { id } = req.params as { id: string };
+  const schema = z.object({ stage_id: z.string().min(1) });
+  const parsed = schema.safeParse(req.body || {});
+  if (!parsed.success)
+    return res.status(400).json({ error: parsed.error.message });
+  const stageId = parsed.data.stage_id;
+
+  try {
+    const context = await resolveChatKanbanContext(id);
+    await ensureInboxWriteAccess(context.chat, req.user.id);
+
+    if (context.leadIds.length === 0) {
+      return res.status(404).json({
+        error: "Nenhum lead vinculado ao chat para atualizar o funil",
+      });
+    }
+
+    const cardIds = context.cards
+      .map((c: any) => String((c as any).id || ""))
+      .filter(Boolean);
+
+    let updatedCards: any[] = [];
+    if (cardIds.length > 0) {
+      const { data: cardRows, error: cardsErr } = await supabaseAdmin
+        .from("kanban_cards")
+        .update({ kanban_column_id: stageId })
+        .in("id", cardIds)
+        .select(
+          "id, kanban_board_id, kanban_column_id, owner_user_id, notes, email, contact, title, value_numeric, source, lead_id",
+        );
+      if (cardsErr) {
+        if ((cardsErr as any)?.code === "23503")
+          return res.status(400).json({ error: "Etapa do funil inválida" });
+        return res.status(500).json({ error: cardsErr.message });
+      }
+      updatedCards = cardRows || [];
+    }
+
+    await supabaseAdmin
+      .from("leads")
+      .update({ kanban_column_id: stageId })
+      .in("id", context.leadIds);
+
+    for (const card of updatedCards) {
+      try {
+        io.emit("kanban:card:updated", mapKanbanCardForResponse(card));
+      } catch {}
+    }
+
+    return res.json({
+      ok: true,
+      stage_id: stageId,
+      cards: updatedCards.map(mapKanbanCardForResponse),
+      lead_ids: context.leadIds,
+    });
+  } catch (e: any) {
+    const status = e?.status || 500;
+    return res
+      .status(status)
+      .json({ error: e?.message || "Falha ao atualizar etapa do funil" });
+  }
+});
+
+app.patch("/livechat/chats/:id/note", requireAuth, async (req: any, res) => {
+  const { id } = req.params as { id: string };
+  const schema = z.object({ note: z.string() });
+  const parsed = schema.safeParse(req.body || {});
+  if (!parsed.success)
+    return res.status(400).json({ error: parsed.error.message });
+  const rawNote = parsed.data.note;
+  const noteValue = rawNote.trim().length === 0 ? null : rawNote;
+
+  try {
+    const context = await resolveChatKanbanContext(id);
+    await ensureInboxWriteAccess(context.chat, req.user.id);
+
+    if (context.leadIds.length === 0) {
+      return res.status(404).json({
+        error: "Nenhum lead vinculado ao chat para atualizar a observação",
+      });
+    }
+
+    const cardIds = context.cards
+      .map((c: any) => String((c as any).id || ""))
+      .filter(Boolean);
+
+    let updatedCards: any[] = [];
+    if (cardIds.length > 0) {
+      const { data: cardRows, error: cardsErr } = await supabaseAdmin
+        .from("kanban_cards")
+        .update({ notes: noteValue })
+        .in("id", cardIds)
+        .select(
+          "id, kanban_board_id, kanban_column_id, owner_user_id, notes, email, contact, title, value_numeric, source, lead_id",
+        );
+      if (cardsErr)
+        return res.status(500).json({ error: cardsErr.message });
+      updatedCards = cardRows || [];
+    }
+
+    await supabaseAdmin
+      .from("leads")
+      .update({ notes: noteValue })
+      .in("id", context.leadIds);
+
+    for (const card of updatedCards) {
+      try {
+        io.emit("kanban:card:updated", mapKanbanCardForResponse(card));
+      } catch {}
+    }
+
+    return res.json({
+      ok: true,
+      note: noteValue,
+      cards: updatedCards.map(mapKanbanCardForResponse),
+      lead_ids: context.leadIds,
+    });
+  } catch (e: any) {
+    const status = e?.status || 500;
+    return res
+      .status(status)
+      .json({ error: e?.message || "Falha ao atualizar observação" });
+  }
+});
+
+// Definir responsável (assignee) do contato do chat, validando com inbox_users
 app.put("/livechat/chats/:id/assignee", requireAuth, async (req: any, res) => {
*** End Patch
