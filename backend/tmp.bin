import "dotenv/config";
import express from "express";
import http from "http";
import { Server as SocketIOServer } from "socket.io";
import cors from "cors";
import cookieParser from "cookie-parser";
import { createClient } from "@supabase/supabase-js";
import { z } from "zod";
import { publishJob } from "./queue/rabbit.ts";

const app = express();
const server = http.createServer(app);

// ===== Config =====
const PORT = Number(process.env.PORT_BACKEND || 5000);
const FRONTEND_ORIGINS = Array.from(
  new Set([
    ...(process.env.FRONTEND_ORIGIN || "")
      .split(",")
      .map((s) => s.trim())
      .filter(Boolean),
    "http://localhost:3000",
    "http://127.0.0.1:3000",
  ]),
);
const SUPABASE_URL = process.env.SUPABASE_URL!;
const SUPABASE_ANON_KEY = process.env.SUPABASE_ANON_KEY!;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY!;
const JWT_COOKIE_NAME = process.env.JWT_COOKIE_NAME || "sb_access_token";
const JWT_COOKIE_SECURE = String(process.env.JWT_COOKIE_SECURE) === "true";

// ===== Middlewares =====
app.use(
  cors({
    origin: FRONTEND_ORIGINS,
    credentials: true,
  }),
);
app.use(express.json({ limit: "10mb" }));
app.use(express.urlencoded({ extended: true }));
app.use(cookieParser());

// (opcional) assets est?ticos se precisar
// app.use(express.static("assets"));

// ===== Supabase clients =====
// Para login/fluxos p?blicos
const supabaseAnon = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
// Para CRUD no servidor (NUNCA exponha essa chave no front)
const supabaseAdmin = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

// ===== Auth middleware =====
async function requireAuth(req: any, res: any, next: any) {
  // pega token do cookie httpOnly ou do header Authorization
  const bearer = (req.headers.authorization ?? "") as string;
  let token = bearer.startsWith("Bearer ") ? bearer.slice(7) : undefined;
  if (!token) token = req.cookies[JWT_COOKIE_NAME];

  if (!token) return res.status(401).json({ error: "Not authenticated" });

  // valida token com Supabase
  const { data, error } = await supabaseAdmin.auth.getUser(token);
  if (error || !data?.user)
    return res.status(401).json({ error: "Invalid token" });

  req.user = data.user;
  next();
}

// ===== Rotas de Auth =====
app.post("/signup", async (req, res) => {
  const { email, password } = req.body ?? {};
  if (!email || !password)
    return res.status(400).json({ error: "Email e senha s o obrigat rios" });

  const { data, error } = await supabaseAnon.auth.signUp({ email, password });
  if (error) return res.status(400).json({ error: error.message });
  return res.status(201).json({ ok: true, user: data.user });
});

app.post("/login", async (req, res) => {
  const { email, password } = req.body ?? {};
  if (!email || !password)
    return res.status(400).json({ error: "Email e senha s o obrigat rios" });

  const { data, error } = await supabaseAnon.auth.signInWithPassword({
    email,
    password,
  });
  if (error || !data?.session)
    return res.status(401).json({ error: "Credenciais inv lidas" });

  const accessToken = data.session.access_token;

  // seta cookie httpOnly para requests subsequentes
  res.cookie(JWT_COOKIE_NAME, accessToken, {
    httpOnly: true,
    secure: JWT_COOKIE_SECURE,
    sameSite: "lax",
    path: "/",
    maxAge: 7 * 24 * 60 * 60 * 1000, // 7 dias
  });

  return res.json({ ok: true, user: data.user });
});

app.post("/logout", (_req, res) => {
  res.clearCookie(JWT_COOKIE_NAME, { path: "/" });
  return res.json({ ok: true });
});

app.get("/auth/me", requireAuth, (req: any, res) => {
  return res.json({ user: req.user });
});

// ===== Queue test/example routes =====
// Enfileira abertura de chat (worker processa)
app.post("/queue/livechat/start-chat", requireAuth, async (req: any, res) => {
  try {
    const { leadId, inboxId } = req.body || {};
    if (!leadId || !inboxId)
      return res.status(400).json({ error: "leadId e inboxId obrigat rios" });
    await publishJob("livechat.startChat", { leadId, inboxId });
    return res.status(202).json({ queued: true });
  } catch (e: any) {
    return res.status(500).json({ error: e?.message || "queue publish error" });
  }
});

// ===== Calend?rio (calendars/events) =====
const VIEW_USER_AGENDA = process.env.VIEW_USER_AGENDA || "user_agenda";
const VIEW_EVENTS_WITH_PARTICIPANTS =
  process.env.VIEW_EVENTS_WITH_PARTICIPANTS || "events_with_participants";
const TABLE_CALENDARS = process.env.TABLE_CALENDARS || "calendars";
const TABLE_EVENTS = process.env.TABLE_EVENTS || "events";
const TABLE_EVENT_PARTICIPANTS =
  process.env.TABLE_EVENT_PARTICIPANTS || "event_participants";

// GET calendars do usu?rio (owner)
app.get("/calendar/calendars", requireAuth, async (req: any, res) => {
  try {
    const authUserId = req.user.id as string;
    // Map auth user -> local users.id
    const { data: urow, error: uerr } = await supabaseAdmin
      .from("users")
      .select("id")
      .eq("user_id", authUserId)
      .maybeSingle();
    if (uerr) return res.status(500).json({ error: uerr.message });
    const ownerId = (urow as any)?.id || null;
    if (!ownerId) return res.json([]);

    const { data, error } = await supabaseAdmin
      .from(TABLE_CALENDARS)
      .select("*")
      .eq("owner_id", ownerId)
      .order("is_default", { ascending: false })
      .order("name", { ascending: true });
    if (error) return res.status(500).json({ error: error.message });
    return res.json(data || []);
  } catch (e: any) {
    return res
      .status(500)
      .json({ error: e?.message || "Calendars list error" });
  }
});

// GET eventos pela janela de datas (interse??o)
// Query params: start, end (ISO strings)
app.get("/calendar/events", requireAuth, async (req: any, res) => {
  try {
    const userId = req.user.id;
    const start = String(req.query.start || "").trim();
    const end = String(req.query.end || "").trim();
    if (!start || !end)
      return res.status(400).json({ error: "start e end obrigat?rios (ISO)" });

    let items: any[] = [];
    let viewFailed = false;
    try {
      const { data, error } = await supabaseAdmin
        .from(VIEW_USER_AGENDA)
        .select("*")
        .eq("user_id", userId)
        .lt("start_time", end)
        .gt("end_time", start)
        .order("start_time", { ascending: true });
      if (error) throw error;
      items = (data || []).map((e: any) => ({
        id: e.id,
        title: e.title,
        start: e.start_time,
        end: e.end_time,
        backgroundColor: e.calendar_color || undefined,
        extendedProps: {
          description: e.description,
          event_type: e.event_type,
          status: e.status,
          location: e.location,
          calendar_name: e.calendar_name,
          calendar_color: e.calendar_color,
          user_id: e.user_id,
          is_organizer: e.is_organizer,
          customer_name: e.customer_name,
          lead_name: e.lead_name,
        },
        raw: e,
      }));
    } catch (e) {
      viewFailed = true;
    }

    if (viewFailed) {
      const { data: evs, error: errEv } = await supabaseAdmin
        .from(TABLE_EVENTS)
        .select(
          "id, title, description, location, event_type, status, start_time, end_time, calendar_id, customer_id",
        )
        .lt("start_time", end)
        .gt("end_time", start)
        .eq("created_by_id", userId)
        .order("start_time", { ascending: true });
      if (errEv) return res.status(500).json({ error: errEv.message });
      const cids = Array.from(
        new Set(
          ((evs as any[]) || [])
            .map((r) => (r as any).calendar_id)
            .filter(Boolean),
        ),
      );
      let cmap: Record<string, { name: string | null; color: string | null }> =
        {};
      if (cids.length > 0) {
        const { data: cals } = await supabaseAdmin
          .from(TABLE_CALENDARS)
          .select("id, name, color")
          .in("id", cids);
        cmap = Object.fromEntries(
          ((cals as any[]) || []).map((c) => [
            (c as any).id,
            { name: (c as any).name || null, color: (c as any).color || null },
          ]),
        );
      }
      items = ((evs as any[]) || []).map((e: any) => {
        const cal = cmap[(e as any).calendar_id] || {};
        return {
          id: e.id,
          title: e.title,
          start: e.start_time,
          end: e.end_time,
          backgroundColor: (cal as any).color || undefined,
          extendedProps: {
            description: e.description,
            event_type: e.event_type,
            status: e.status,
            location: e.location,
            calendar_name: (cal as any).name || null,
            calendar_color: (cal as any).color || null,
            user_id: userId,
            is_organizer: true,
          },
          raw: e,
        };
      });
    }

    return res.json({ items });
  } catch (e: any) {
    return res.status(500).json({ error: e?.message || "Events list error" });
  }
});

// Valida disponibilidade simples chamando fun??o RPC is_user_available_simple
async function checkAvailability(
  userId: string,
  startISO: string,
  endISO: string,
) {
  const { data, error } = await (supabaseAdmin as any).rpc(
    "is_user_available_simple",
    {
      p_user_id: userId,
      p_start_time: startISO,
      p_end_time: endISO,
    },
  );
  if (error) throw new Error(error.message);
  return Boolean(data);
}

// POST criar evento + participantes
app.post("/calendar/events", requireAuth, async (req: any, res) => {
  try {
    const userId = req.user.id;
    const schema = z.object({
      title: z.string().min(1),
      description: z.string().optional().nullable(),
      location: z.string().optional().nullable(),
      event_type: z
        .enum(["MEETING", "CALL", "TECHNICAL_VISIT", "FOLLOW_UP", "OTHER"])
        .optional(),
      status: z.enum(["SCHEDULED", "COMPLETED", "CANCELLED"]).optional(),
      start_time: z.string().min(1), // ISO
      end_time: z.string().min(1), // ISO
      calendar_id: z.string().uuid(),
      participant_ids: z.array(z.string().uuid()).optional().default([]),
      customer_id: z.string().uuid().optional(),
    });
    const parsed = schema.safeParse(req.body || {});
    if (!parsed.success)
      return res.status(400).json({ error: parsed.error.message });
    const payload = parsed.data;

    if (new Date(payload.end_time) <= new Date(payload.start_time)) {
      return res
        .status(400)
        .json({ error: "end_time deve ser maior que start_time" });
    }

    // checa disponibilidade do criador e participantes
    const participantsAll = Array.from(
      new Set([userId, ...payload.participant_ids]),
    );
    const availabilityResults: Record<string, boolean> = {};
    for (const uid of participantsAll) {
      availabilityResults[uid] = await checkAvailability(
        uid,
        payload.start_time,
        payload.end_time,
      );
    }
    const busy = Object.entries(availabilityResults)
      .filter(([, ok]) => !ok)
      .map(([uid]) => uid);
    if (busy.length > 0) {
      return res.status(409).json({
        error: "Usu?rios indispon?veis para o intervalo",
        busy_user_ids: busy,
      });
    }

    // cria evento
    const eventInsert: any = {
      title: payload.title,
      description: payload.description ?? null,
      location: payload.location ?? null,
      event_type: payload.event_type ?? "OTHER",
      status: payload.status ?? "SCHEDULED",
      start_time: payload.start_time,
      end_time: payload.end_time,
      is_all_day: false,
      calendar_id: payload.calendar_id,
      created_by_id: userId,
      customer_id: payload.customer_id ?? null,
    };
    const { data: ev, error: evErr } = await supabaseAdmin
      .from(TABLE_EVENTS)
      .insert(eventInsert)
      .select("*")
      .single();
    if (evErr) return res.status(500).json({ error: evErr.message });

    // participantes: criador como organizer + demais
    const rows = [
      { event_id: ev.id, user_id: userId, is_organizer: true },
      ...payload.participant_ids
        .filter((uid) => uid !== userId)
        .map((uid) => ({ event_id: ev.id, user_id: uid, is_organizer: false })),
    ];
    if (rows.length > 0) {
      const { error: pErr } = await supabaseAdmin
        .from(TABLE_EVENT_PARTICIPANTS)
        .insert(rows);
      if (pErr) return res.status(500).json({ error: pErr.message });
    }

    return res.status(201).json(ev);
  } catch (e: any) {
    return res.status(500).json({ error: e?.message || "Create event error" });
  }
});

// PUT atualizar evento
app.put("/calendar/events/:id", requireAuth, async (req: any, res) => {
  try {
    const { id } = req.params as { id: string };
    const schema = z.object({
      title: z.string().optional(),
      description: z.string().optional().nullable(),
      location: z.string().optional().nullable(),
      event_type: z
        .enum(["MEETING", "CALL", "TECHNICAL_VISIT", "FOLLOW_UP", "OTHER"])
        .optional(),
      status: z.enum(["SCHEDULED", "COMPLETED", "CANCELLED"]).optional(),
      start_time: z.string().optional(),
      end_time: z.string().optional(),
      is_all_day: z.boolean().optional(),
    });
    const parsed = schema.safeParse(req.body || {});
    if (!parsed.success)
      return res.status(400).json({ error: parsed.error.message });

    const patch = parsed.data as any;
    if (patch.start_time && patch.end_time) {
      if (new Date(patch.end_time) <= new Date(patch.start_time)) {
        return res
          .status(400)
          .json({ error: "end_time deve ser maior que start_time" });
      }
    }

    const { data, error } = await supabaseAdmin
      .from(TABLE_EVENTS)
      .update({ ...patch, updated_at: new Date().toISOString() })
      .eq("id", id)
      .select("*")
      .single();
    if (error) return res.status(500).json({ error: error.message });
    return res.json(data);
  } catch (e: any) {
    return res.status(500).json({ error: e?.message || "Update event error" });
  }
});

// DELETE evento
app.delete("/calendar/events/:id", requireAuth, async (req: any, res) => {
  try {
    const { id } = req.params as { id: string };
    const { error } = await supabaseAdmin
      .from(TABLE_EVENTS)
      .delete()
      .eq("id", id);
    if (error) return res.status(500).json({ error: error.message });
    return res.status(204).send();
  } catch (e: any) {
    return res.status(500).json({ error: e?.message || "Delete event error" });
  }
});

// GET disponibilidade simples
app.get("/calendar/availability", requireAuth, async (req: any, res) => {
  try {
    const userId = (req.query.user_id as string) || req.user.id;
    const start = String(req.query.start || "").trim();
    const end = String(req.query.end || "").trim();
    if (!userId || !start || !end)
      return res
        .status(400)
        .json({ error: "user_id, start, end obrigat?rios" });
    const available = await checkAvailability(userId, start, end);
    return res.json({ user_id: userId, available });
  } catch (e: any) {
    return res.status(500).json({ error: e?.message || "Availability error" });
  }
});

// ===== Produtos =====
const PRODUCTS_TABLE = process.env.PRODUCTS_TABLE || "products";

// GET listar produtos (suporta pagina??o e filtros)
app.get("/products", requireAuth, async (req, res) => {
  try {
    const q = (req.query.q as string | undefined)?.trim();
    const status = (req.query.status as string | undefined)?.trim();
    const limit = req.query.limit ? Number(req.query.limit) : undefined;
    const offset = req.query.offset ? Number(req.query.offset) : undefined;

    let query = supabaseAdmin
      .from(PRODUCTS_TABLE)
      .select("*", { count: "exact" })
      .order("updated_at", { ascending: false });

    if (q) {
      // filtro por nome (ilike)
      query = query.ilike("name", `%${q}%`);
    }
    if (status && status.toLowerCase() !== "all") {
      query = query.eq("status", status);
    }

    if (typeof limit === "number" && typeof offset === "number") {
      // Supabase usa range inclusivo
      query = query.range(offset, offset + Math.max(0, limit - 1));
    }

    const { data, error, count } = await query;
    if (error) return res.status(500).json({ error: error.message });
    return res.json({ items: data || [], total: count ?? (data?.length || 0) });
  } catch (e: any) {
    return res.status(500).json({ error: e?.message || "Products list error" });
  }
});

// POST criar produto
app.post("/products", requireAuth, async (req, res) => {
  try {
    const schema = z
      .object({
        external_id: z.string().optional(),
        name: z.string().min(1),
        unit: z.string().nullable().optional(),
        cost_price: z.union([z.number(), z.string()]).nullable().optional(),
        sale_price: z.union([z.number(), z.string()]).nullable().optional(),
        brand: z.string().nullable().optional(),
        grouping: z.string().nullable().optional(),
        power: z.string().nullable().optional(),
        size: z.string().nullable().optional(),
        supplier: z.string().nullable().optional(),
        status: z.string().nullable().optional(),
        specs: z.string().nullable().optional(),
      })
      .passthrough();

    const parseMoney = (v: any): number | null => {
      if (v === null || v === undefined || v === "") return null;
      if (typeof v === "number") return v;
      if (typeof v !== "string") return null;
      const s = v
        .replace(/\./g, "")
        .replace(/,/, ".")
        .replace(/[^0-9.-]/g, "");
      const n = Number(s);
      return isNaN(n) ? null : n;
    };

    const parsed = schema.safeParse(req.body || {});
    if (!parsed.success)
      return res.status(400).json({ error: parsed.error.message });

    const payload: any = { ...parsed.data };
    if (payload.cost_price !== undefined)
      payload.cost_price = parseMoney(payload.cost_price);
    if (payload.sale_price !== undefined)
      payload.sale_price = parseMoney(payload.sale_price);

    const { data, error } = await supabaseAdmin
      .from(PRODUCTS_TABLE)
      .insert([payload])
      .select("*")
      .single();
    if (error) return res.status(500).json({ error: error.message });
    return res.status(201).json(data);
  } catch (e: any) {
    return res
      .status(500)
      .json({ error: e?.message || "Create product error" });
  }
});

// PUT atualizar produto por id
app.put("/products/:id", requireAuth, async (req, res) => {
  const { id } = req.params as { id: string };

  const schema = z
    .object({
      external_id: z.string().optional(),
      name: z.string().optional(),
      unit: z.string().nullable().optional(),
      cost_price: z.union([z.number(), z.string()]).nullable().optional(),
      sale_price: z.union([z.number(), z.string()]).nullable().optional(),
      brand: z.string().nullable().optional(),
      grouping: z.string().nullable().optional(),
      power: z.string().nullable().optional(),
      size: z.string().nullable().optional(),
      supplier: z.string().nullable().optional(),
      status: z.string().nullable().optional(),
      specs: z.string().nullable().optional(),
    })
    .passthrough();

  const parseMoney = (v: any): number | null => {
    if (v === null || v === undefined || v === "") return null;
    if (typeof v === "number") return v;
    if (typeof v !== "string") return null;
    const s = v
      .replace(/\./g, "")
      .replace(/,/, ".")
      .replace(/[^0-9.-]/g, "");
    const n = Number(s);
    return isNaN(n) ? null : n;
  };

  const parsed = schema.safeParse(req.body || {});
  if (!parsed.success)
    return res.status(400).json({ error: parsed.error.message });

  const payload: any = { ...parsed.data };
  if (payload.cost_price !== undefined)
    payload.cost_price = parseMoney(payload.cost_price);
  if (payload.sale_price !== undefined)
    payload.sale_price = parseMoney(payload.sale_price);
  payload.updated_at = new Date().toISOString();

  const { data, error } = await supabaseAdmin
    .from(PRODUCTS_TABLE)
    .update(payload)
    .eq("id", id)
    .select("*")
    .single();

  if (error) return res.status(500).json({ error: error.message });
  return res.json(data);
});

// DELETE produto por id
app.delete("/products/:id", requireAuth, async (req, res) => {
  const { id } = req.params as { id: string };
  const { error } = await supabaseAdmin
    .from(PRODUCTS_TABLE)
    .delete()
    .eq("id", id);
  if (error) return res.status(500).json({ error: error.message });
  return res.status(204).send();
});

// POST upsert em massa de produtos
app.post("/products/bulk-upsert", requireAuth, async (req, res) => {
  const items = (req.body || []) as any[];
  if (!Array.isArray(items))
    return res.status(400).json({ error: "Body deve ser array" });

  const schema = z.object({
    external_id: z.string().min(1),
    name: z.string().min(1),
    unit: z.string().optional().nullable(),
    cost_price: z.union([z.number(), z.string()]).optional().nullable(),
    sale_price: z.union([z.number(), z.string()]).optional().nullable(),
    brand: z.string().optional().nullable(),
    grouping: z.string().optional().nullable(),
    power: z.string().optional().nullable(),
    size: z.string().optional().nullable(),
    supplier: z.string().optional().nullable(),
    status: z.string().optional().nullable(),
    specs: z.string().optional().nullable(),
  });

  const parseMoney = (v: any): number | null => {
    if (v === null || v === undefined || v === "") return null;
    if (typeof v === "number") return v;
    if (typeof v !== "string") return null;
    const s = v
      .replace(/\./g, "")
      .replace(/,/, ".")
      .replace(/[^0-9.-]/g, "");
    const n = Number(s);
    return isNaN(n) ? null : n;
  };

  const toUpsert = [] as any[];
  for (const raw of items) {
    const parsed = schema.safeParse(raw);
    if (!parsed.success) {
      return res
        .status(400)
        .json({ error: "Item inv lido", details: parsed.error.format() });
    }
    const r = parsed.data as any;
    toUpsert.push({
      external_id: String(r.external_id),
      name: r.name,
      unit: r.unit ?? null,
      cost_price: parseMoney(r.cost_price),
      sale_price: parseMoney(r.sale_price),
      brand: r.brand ?? null,
      grouping: r.grouping ?? null,
      power: r.power ?? null,
      size: r.size ?? null,
      supplier: r.supplier ?? null,
      status: r.status ?? null,
      specs: r.specs ?? null,
      updated_at: new Date().toISOString(),
    });
  }

  const { data, error } = await supabaseAdmin
    .from(PRODUCTS_TABLE)
    .upsert(toUpsert, { onConflict: "external_id" })
    .select("*");

  if (error) return res.status(500).json({ error: error.message });
  return res.json({ upserted: data?.length || 0 });
});

// Perfil do Usu rio autenticado + dados b?sicos da empresa
app.get("/me/profile", requireAuth, async (req: any, res) => {
  const userId = req.user.id;
  // Tenta obter linha em public.users
  const { data: urow, error: uerr } = await supabaseAdmin
    .from("users")
    .select("user_id, name, role, avatar, company_id")
    .eq("user_id", userId)
    .maybeSingle();
  if (uerr) return res.status(500).json({ error: uerr.message });

  let companyName: string | null = null;
  // Opcional: tenta buscar nome da empresa, ignora se a tabela n?o existir
  try {
    if (urow?.company_id) {
      const { data: comp, error: cerr } = await supabaseAdmin
        .from("companies")
        .select("id, name")
        .eq("id", urow.company_id)
        .maybeSingle();
      if (!cerr) companyName = (comp as any)?.name ?? null;
    }
  } catch (_) {
    // ignora
  }

  return res.json({
    id: req.user.id,
    email: req.user.email,
    name: urow?.name || req.user.email,
    role: urow?.role || null,
    avatarUrl: urow?.avatar || null,
    companyId: urow?.company_id || null,
    companyName,
  });
});

// Update authenticated user's profile (name/avatar/password)
app.put("/me/profile", requireAuth, async (req: any, res) => {
  try {
    const authUserId = req.user.id as string;
    const authEmail = req.user.email as string;
    const schema = z
      .object({
        name: z.string().min(1).optional(),
        avatarUrl: z.string().url().optional(),
        currentPassword: z.string().optional(),
        newPassword: z.string().optional(),
        confirmPassword: z.string().optional(),
      })
      .passthrough();
    const parsed = schema.safeParse(req.body || {});
    if (!parsed.success)
      return res
        .status(400)
        .json({ error: "Dados inv?lidos", details: parsed.error.format() });
    const body = parsed.data as any;

    const nowIso = new Date().toISOString();
    let updatedRow: any = null;
    const toUpdate: Record<string, any> = {};
    if (typeof body.name === "string") toUpdate.name = body.name;
    if (typeof body.avatarUrl === "string") toUpdate.avatar = body.avatarUrl;
    if (Object.keys(toUpdate).length > 0) {
      toUpdate.updated_at = nowIso;
      const { data, error } = await supabaseAdmin
        .from("users")
        .update(toUpdate)
        .eq("user_id", authUserId)
        .select("user_id, name, role, avatar, company_id")
        .maybeSingle();
      if (error) return res.status(500).json({ error: error.message });
      updatedRow = data;
    }

    let passwordChanged = false;
    const hasPwChange =
      typeof body.newPassword === "string" && body.newPassword.length > 0;
    if (hasPwChange) {
      if (!body.currentPassword)
        return res.status(400).json({ error: "Senha atual ? obrigat?ria" });
      if (body.newPassword !== body.confirmPassword)
        return res
          .status(400)
          .json({ error: "Confirma??o de senha n?o confere" });
      // Validate current password by trying to sign in
      const { data: login, error: loginErr } =
        await supabaseAnon.auth.signInWithPassword({
          email: authEmail,
          password: String(body.currentPassword),
        });
      if (loginErr || !login?.session)
        return res.status(400).json({ error: "Senha atual inv?lida" });
      // Update password using admin
      const { error: upwErr } = await (
        supabaseAdmin as any
      ).auth.admin.updateUserById(authUserId, {
        password: String(body.newPassword),
      });
      if (upwErr) return res.status(500).json({ error: upwErr.message });
      passwordChanged = true;
    }

    const resp = {
      id: authUserId,
      email: authEmail,
      name: updatedRow?.name ?? req.user.email,
      role: updatedRow?.role ?? null,
      avatarUrl: updatedRow?.avatar ?? null,
      companyId: updatedRow?.company_id ?? null,
      passwordChanged,
    };

    try {
      io.emit("profile:updated", {
        userId: authUserId,
        changes: { name: toUpdate.name, avatarUrl: toUpdate.avatar },
        profile: resp,
      });
    } catch {}
    return res.json(resp);
  } catch (e: any) {
    return res
      .status(500)
      .json({ error: e?.message || "profile update error" });
  }
});

// ===== Rotas de Leads (exemplo CRUD) =====
// Ajuste nomes de colunas conforme sua tabela "Lead"

type LeadForm = {
  tipoPessoa?: string;
  cpf?: string;
  nome?: string;
  rg?: string;
  orgao?: string;
  dataNascimento?: string;
  mae?: string;
  pai?: string;
  sexo?: string;
  naturalidade?: string;
  estadoCivil?: string;
  conjuge?: string;
  cep?: string;
  rua?: string;
  numero?: string;
  complemento?: string;
  bairro?: string;
  uf?: string;
  cidade?: string;
  celular?: string;
  celularAlternativo?: string;
  telefone?: string;
  telefoneAlternativo?: string;
  email?: string;
  site?: string;
  observacoes?: string;
  status?: string;
  // suporte para etapa/coluna do kanban
  etapa?: string; // alias amig?vel no front
  kanban_column_id?: string; // id da coluna do kanban
};

export function mapLead(form: LeadForm) {
  return {
    personType: form.tipoPessoa ?? null,
    phone: form.telefone,
    cpf: form.cpf ?? null,
    name: form.nome,
    rg: form.rg ?? null,
    rgOrgao: form.orgao ?? null,
    birthDate: form.dataNascimento
      ? new Date(form.dataNascimento).toISOString()
      : null,
    mother: form.mae ?? null,
    father: form.pai ?? null,
    gender: form.sexo ?? null,
    birthPlace: form.naturalidade ?? null,
    maritalStatus: form.estadoCivil ?? null,
    spouse: form.conjuge ?? null,
    cep: form.cep ?? null,
    street: form.rua ?? null,
    number: form.numero ?? null,
    complement: form.complemento ?? null,
    neighborhood: form.bairro ?? null,
    state: form.uf ?? null,
    city: form.cidade ?? null,
    cellphone: form.celular ?? null,
    altCellphone: form.celularAlternativo ?? null,
    telephone: form.telefone ?? null,
    altTelephone: form.telefoneAlternativo ?? null,
    email: form.email ?? null,
    site: form.site ?? null,
    notes: form.observacoes ?? null,
    statusClient: form.status ?? "Ativo",
    // persiste a etapa do kanban quando enviado pelo front (coluna ?nica)
    kanban_column_id: (form.kanban_column_id || form.etapa) ?? null,
  };
}

// LISTAR
app.get("/leads", requireAuth, async (_req, res) => {
  const { data, error } = await supabaseAdmin
    .from("leads")
    .select("*")
    .order("created_at", { ascending: false });

  if (error) return res.status(500).json({ error: error.message });

  const mapped = (data ?? []).map((r: any) => ({
    id: r.id,
    name: r.name,
    cpf: r.cpf,
    email: r.email,
    status: r.status_client ?? r.status,
    // exp?e a coluna/etapa do kanban para o front
    kanban_column_id: r.kanban_column_id,

    tipoPessoa: r.person_type,
    rg: r.rg,
    orgao: r.rg_orgao,
    dataNascimento: r.birth_date,
    mae: r.mother,
    pai: r.father,
    sexo: r.gender,
    naturalidade: r.birth_place,
    estadoCivil: r.marital_status,
    conjuge: r.spouse,

    cep: r.cep,
    rua: r.street,
    numero: r.number,
    complemento: r.complement,
    bairro: r.neighborhood,
    uf: r.state,
    cidade: r.city,

    celular: r.cellphone,
    celularAlternativo: r.alt_cellphone,
    telefone: r.telephone,
    telefoneAlternativo: r.alt_telephone,

    site: r.site,
    observacoes: r.notes,

    createdAt: r.created_at,
    updatedAt: r.updated_at,
  }));

  return res.json(mapped);
});

// Get lead by id (minimal fields needed for receipts)
app.get("/leads/:id", requireAuth, async (req: any, res) => {
  try {
    const { id } = req.params as { id: string };
    const { data, error } = await supabaseAdmin
      .from("leads")
      .select("id, name, email, phone, cpf, rg, city, state")
      .eq("id", id)
      .maybeSingle();
    if (error) return res.status(500).json({ error: error.message });
    if (!data) return res.status(404).json({ error: "Lead n o encontrado" });
    return res.json(data);
  } catch (e: any) {
    return res.status(500).json({ error: e?.message || "leads get error" });
  }
});

// Get minimal lead by customer_id (useful when proposal doesn't store lead_id)
app.get(
  "/leads/by-customer/:customerId",
  requireAuth,
  async (req: any, res) => {
    try {
      const { customerId } = req.params as { customerId: string };

      const selectColumns =
        "id, name, email, phone, cpf, rg, city, state, customer_id, kanban_column_id";

      const { data: leadByCustomer, error: leadByCustomerErr } =
        await supabaseAdmin
          .from("leads")
          .select(selectColumns)
          .eq("customer_id", customerId)
          .order("updated_at", { ascending: false })
          .limit(1)
          .maybeSingle();

      if (leadByCustomerErr) {
        return res.status(500).json({ error: leadByCustomerErr.message });
      }
      if (leadByCustomer) {
        return res.json(leadByCustomer);
      }

      const { data: leadById, error: leadByIdErr } = await supabaseAdmin
        .from("leads")
        .select(selectColumns)
        .eq("id", customerId)
        .maybeSingle();

      if (leadByIdErr) {
        return res.status(500).json({ error: leadByIdErr.message });
      }
      if (leadById) {
        return res.json(leadById);
      }

      const { data: customer, error: customerErr } = await supabaseAdmin
        .from("customers")
        .select("id, name, email, phone")
        .eq("id", customerId)
        .maybeSingle();

      if (customerErr) {
        return res.status(500).json({ error: customerErr.message });
      }
      if (customer) {
        return res.json({
          id: customer.id,
          customer_id: customer.id,
          name: customer.name,
          email: (customer as any).email || null,
          phone: (customer as any).phone || null,
        });
      }

      return res.json(null);
    } catch (e: any) {
      return res
        .status(500)
        .json({ error: e?.message || "leads by customer error" });
    }
  },
);

// CRIAR
app.post("/leads", requireAuth, async (req, res) => {
  const payload = mapLead(req.body);
  if (!payload.name)
    return res.status(400).json({ error: "Campo 'nome'   obrigat rio" });

  const leadSchema = z
    .object({
      nome: z.string().min(1),
      cpf: z
        .string()
        .regex(/^\d{11}$/, "CPF inv lido")
        .optional(),
      cep: z
        .string()
        .regex(/^\d{8}$/, "CEP inv lido")
        .optional(),
      uf: z.string().max(2).optional(),
      email: z.string().email().optional(),
      telefone: z.string().max(11).optional(),
      celular: z.string().max(11).optional(),
      numero: z.string().max(10).optional(),
      dataNascimento: z.string().optional(), // voc? pode validar ISO aqui tamb?m
    })
    .passthrough();

  const { data, error } = await supabaseAdmin
    .from("leads")
    .insert([payload])
    .select("*")
    .single();

  if (error) return res.status(500).json({ error: error.message });
  return res.status(201).json(data);
});

// ATUALIZAR
app.put("/leads/:id", requireAuth, async (req, res) => {
  const { id } = req.params;
  const payload = mapLead(req.body);
  const { data, error } = await supabaseAdmin
    .from("leads")
    .update(payload)
    .eq("id", id)
    .select()
    .single();

  const leadSchema = z
    .object({
      nome: z.string().min(1),
      cpf: z
        .string()
        .regex(/^\d{11}$/, "CPF inv lido")
        .optional(),
      cep: z
        .string()
        .regex(/^\d{8}$/, "CEP inv lido")
        .optional(),
      uf: z.string().max(2).optional(),
      email: z.string().email().optional(),
      telefone: z.string().max(11).optional(),
      celular: z.string().max(11).optional(),
      numero: z.string().max(10).optional(),
      dataNascimento: z.string().optional(), // voc? pode validar ISO aqui tamb?m
    })
    .passthrough();

  if (error) return res.status(500).json({ error: error.message });
  return res.json(data);
});

// APAGAR
app.delete("/leads/:id", requireAuth, async (req, res) => {
  const { id } = req.params;
  const { error } = await supabaseAdmin.from("leads").delete().eq("id", id);
  if (error) return res.status(500).json({ error: error.message });
  return res.status(204).send();
});

// ===== Live Chat =====
// Inboxes do usu?rio autenticado
app.get("/livechat/inboxes/my", requireAuth, async (req: any, res) => {
  try {
    const authUserId = req.user.id as string;

    // Primeiro tenta direto com auth.user.id (caso inbox_users.user_id armazene o auth id)
    let { data: links, error: errLinks } = await supabaseAdmin
      .from("inbox_users")
      .select("inbox_id")
      .eq("user_id", authUserId);
    if (errLinks) return res.status(500).json({ error: errLinks.message });

    // Fallback: alguns esquemas armazenam o id local de public.users (PK) em inbox_users.user_id
    if (!links || links.length === 0) {
      try {
        const { data: urow } = await supabaseAdmin
          .from("users")
          .select("id")
          .eq("user_id", authUserId)
          .maybeSingle();
        if (urow?.id) {
          const resp2 = await supabaseAdmin
            .from("inbox_users")
            .select("inbox_id")
            .eq("user_id", urow.id);
          if (!resp2.error) links = resp2.data as any[];
        }
      } catch {}
    }

    const ids = Array.from(
      new Set((links || []).map((r: any) => r.inbox_id)),
    ).filter(Boolean);
    if (ids.length === 0) return res.json([]);

    const { data, error } = await supabaseAdmin
      .from("inboxes")
      .select("id, name, phone_number, is_active")
      .in("id", ids)
      .eq("is_active", true)
      .order("name", { ascending: true });
    if (error) return res.status(500).json({ error: error.message });
    return res.json(data || []);
  } catch (e: any) {
    return res.status(500).json({ error: e?.message || "inboxes fetch error" });
  }
});

// List all inboxes of current user's company
app.get("/livechat/inboxes", requireAuth, async (req: any, res) => {
  try {
    const { data: urow, error: uerr } = await supabaseAdmin
      .from("users")
      .select("company_id, role")
      .eq("user_id", req.user.id)
      .maybeSingle();
    if (uerr) return res.status(500).json({ error: uerr.message });
    const companyId = (urow as any)?.company_id;
    if (!companyId)
      return res.status(404).json({ error: "Usu?rio sem company_id" });
    const { data, error } = await supabaseAdmin
      .from("inboxes")
      .select(
        "id, name, phone_number, is_active, webhook_url, channel, provider, base_url, api_version, phone_number_id, waba_id, instance_id, created_at, updated_at",
      )
      .eq("company_id", companyId)
      .order("created_at", { ascending: false });
    if (error) return res.status(500).json({ error: error.message });
    return res.json(data || []);
  } catch (e: any) {
    return res.status(500).json({ error: e?.message || "inboxes list error" });
  }
});

// Create a new inbox in current company
app.post("/livechat/inboxes", requireAuth, async (req: any, res) => {
  try {
    const { data: urow, error: uerr } = await supabaseAdmin
      .from("users")
      .select("company_id, role, id")
      .eq("user_id", req.user.id)
      .maybeSingle();
    if (uerr) return res.status(500).json({ error: uerr.message });
    const companyId = (urow as any)?.company_id as string | null;
    if (!companyId)
      return res.status(404).json({ error: "Usu?rio sem company_id" });
    const actorLocalUserId = (urow as any)?.id || null;

    const schema = z.object({
      name: z.string().min(1),
      phone_number: z.string().min(5),
      webhook_url: z.string().url().optional().nullable(),
      channel: z.string().optional().default("WHATSAPP"),
      provider: z.string().optional().default("META_CLOUD"),
      base_url: z.string().url().optional().nullable(),
      api_version: z.string().optional().nullable(),
      phone_number_id: z.string().optional().nullable(),
      waba_id: z.string().optional().nullable(),
      instance_id: z.string().optional().nullable(),
      webhook_verify_token: z.string().optional().nullable(),
      app_secret: z.string().optional().nullable(),
      add_current_as_manager: z.boolean().optional().default(true),
    });
    const parsed = schema.safeParse(req.body || {});
    if (!parsed.success)
      return res
        .status(400)
        .json({ error: "Dados inv?lidos", details: parsed.error.format() });
    const b = parsed.data as any;

    const nowIso = new Date().toISOString();
    const insert = {
      name: b.name,
      phone_number: b.phone_number,
      webhook_url: b.webhook_url ?? null,
      channel: b.channel || "WHATSAPP",
      provider: b.provider || "META_CLOUD",
      base_url: b.base_url ?? null,
      api_version: b.api_version ?? null,
      phone_number_id: b.phone_number_id ?? null,
      waba_id: b.waba_id ?? null,
      instance_id: b.instance_id ?? null,
      company_id: companyId,
      created_at: nowIso,
      updated_at: nowIso,
    } as any;

    const { data: inbox, error } = await supabaseAdmin
      .from("inboxes")
      .insert([insert])
      .select(
        "id, name, phone_number, is_active, webhook_url, channel, provider, base_url, api_version, phone_number_id, waba_id, instance_id, created_at, updated_at, company_id",
      )
      .single();
    if (error) return res.status(500).json({ error: error.message });

    // secrets
    if (b.webhook_verify_token || b.app_secret) {
      await supabaseAdmin
        .from("inbox_secrets")
        .upsert(
          [
            {
              inbox_id: (inbox as any).id,
              access_token: null,
              refresh_token: null,
              provider_api_key: null,
              updated_at: nowIso,
            },
          ],
          { onConflict: "inbox_id" },
        );
      const patch: any = {};
      if (b.webhook_verify_token !== undefined)
        patch.webhook_verify_token = b.webhook_verify_token;
      if (b.app_secret !== undefined) patch.app_secret = b.app_secret;
      if (Object.keys(patch).length > 0) {
        await supabaseAdmin
          .from("inboxes")
          .update(patch)
          .eq("id", (inbox as any).id);
      }
    }

    // link actor as manager
    try {
      if (b.add_current_as_manager && actorLocalUserId) {
        await supabaseAdmin
          .from("inbox_users")
          .upsert(
            [
              {
                user_id: actorLocalUserId,
                inbox_id: (inbox as any).id,
                can_read: true,
                can_write: true,
                can_manage: true,
              },
            ],
            { onConflict: "user_id,inbox_id" },
          );
      }
    } catch {}

    try {
      io.emit("inbox:created", { companyId, inbox });
    } catch {}
    return res.status(201).json(inbox);
  } catch (e: any) {
    return res.status(500).json({ error: e?.message || "inbox create error" });
  }
});

// Update inbox settings (non-secret and selected secret-like fields stored on inbox)
app.put("/livechat/inboxes/:id", requireAuth, async (req: any, res) => {
  try {
    const { id } = req.params as { id: string };
    // Load inbox and user for permission
    const { data: inbox, error: iErr } = await supabaseAdmin
      .from("inboxes")
      .select("id, company_id")
      .eq("id", id)
      .maybeSingle();
    if (iErr) return res.status(500).json({ error: iErr.message });
    if (!inbox) return res.status(404).json({ error: "Inbox n?o encontrada" });
    const { data: urow, error: uerr } = await supabaseAdmin
      .from("users")
      .select("company_id, role, id")
      .eq("user_id", req.user.id)
      .maybeSingle();
    if (uerr) return res.status(500).json({ error: uerr.message });
    const sameCompany = (urow as any)?.company_id === (inbox as any).company_id;
    if (!sameCompany) return res.status(403).json({ error: "Proibido" });
    let allowed = false;
    const role = ((urow as any)?.role || "").toString().toUpperCase();
    if (role && role !== "AGENT") allowed = true;
    if (!allowed) {
      const { data: link } = await supabaseAdmin
        .from("inbox_users")
        .select("can_manage")
        .eq("inbox_id", id)
        .eq("user_id", (urow as any)?.id)
        .maybeSingle();
      if (link?.can_manage) allowed = true;
    }
    if (!allowed)
      return res
        .status(403)
        .json({ error: "Sem permiss?o para editar esta inbox" });

    const schema = z
      .object({
        name: z.string().min(1).optional(),
        phone_number: z.string().min(5).optional(),
        is_active: z.boolean().optional(),
        webhook_url: z.string().url().optional().nullable(),
        channel: z.string().optional(),
        provider: z.string().optional(),
        base_url: z.string().optional().nullable(),
        api_version: z.string().optional().nullable(),
        phone_number_id: z.string().optional().nullable(),
        waba_id: z.string().optional().nullable(),
        instance_id: z.string().optional().nullable(),
        webhook_verify_token: z.string().optional().nullable(),
        app_secret: z.string().optional().nullable(),
      })
      .passthrough();
    const parsed = schema.safeParse(req.body || {});
    if (!parsed.success)
      return res
        .status(400)
        .json({ error: "Dados inv?lidos", details: parsed.error.format() });
    const b = parsed.data as any;
    const update: any = {};
    const fields = [
      "name",
      "phone_number",
      "is_active",
      "webhook_url",
      "channel",
      "provider",
      "base_url",
      "api_version",
      "phone_number_id",
      "waba_id",
      "instance_id",
      "webhook_verify_token",
      "app_secret",
    ];
    for (const k of fields)
      if (Object.prototype.hasOwnProperty.call(b, k)) update[k] = b[k];
    update.updated_at = new Date().toISOString();
    if (Object.keys(update).length === 1)
      return res.status(400).json({ error: "Nada para atualizar" });
    const { data: updated, error } = await supabaseAdmin
      .from("inboxes")
      .update(update)
      .eq("id", id)
      .select(
        "id, name, phone_number, is_active, webhook_url, channel, provider, base_url, api_version, phone_number_id, waba_id, instance_id, created_at, updated_at, company_id",
      )
      .single();
    if (error) return res.status(500).json({ error: error.message });
    try {
      io.emit("inbox:updated", {
        inboxId: id,
        companyId: (updated as any).company_id,
        changes: update,
        inbox: updated,
      });
    } catch {}
    return res.json(updated);
  } catch (e: any) {
    return res.status(500).json({ error: e?.message || "inbox update error" });
  }
});

// Delete inbox
app.delete("/livechat/inboxes/:id", requireAuth, async (req: any, res) => {
  try {
    const { id } = req.params as { id: string };
    const { data: inbox, error: inboxErr } = await supabaseAdmin
      .from("inboxes")
      .select("id, company_id")
      .eq("id", id)
      .maybeSingle();
    if (inboxErr) return res.status(500).json({ error: inboxErr.message });
    if (!inbox) return res.status(404).json({ error: "Inbox nao encontrada" });

    const { data: actor, error: actorErr } = await supabaseAdmin
      .from("users")
      .select("id, role, company_id")
      .eq("user_id", req.user.id)
      .maybeSingle();
    if (actorErr) return res.status(500).json({ error: actorErr.message });
    if (!actor || (actor as any).company_id !== (inbox as any).company_id)
      return res.status(403).json({ error: "Proibido" });

    let allowed = false;
    const role = ((actor as any).role || "").toString().toUpperCase();
    if (role && role !== "AGENT") allowed = true;
    if (!allowed) {
      const { data: link, error: linkErr } = await supabaseAdmin
        .from("inbox_users")
        .select("can_manage")
        .eq("inbox_id", id)
        .eq("user_id", (actor as any).id)
        .maybeSingle();
      if (linkErr) return res.status(500).json({ error: linkErr.message });
      if (link?.can_manage) allowed = true;
    }
    if (!allowed)
      return res
        .status(403)
        .json({ error: "Sem permissao para excluir inbox" });

    const { data: chats } = await supabaseAdmin
      .from("chats")
      .select("id")
      .eq("inbox_id", id);
    const chatIds = (chats || []).map((row: any) => row.id).filter(Boolean);
    if (chatIds.length > 0) {
      const chunk = (arr: any[], size = 100) => {
        const parts: any[][] = [];
        for (let i = 0; i < arr.length; i += size)
          parts.push(arr.slice(i, i + size));
        return parts;
      };
      for (const part of chunk(chatIds, 100)) {
        try {
          await supabaseAdmin
            .from("chat_messages")
            .delete()
            .in("chat_id", part);
        } catch {}
        try {
          await supabaseAdmin
            .from("chat_participants")
            .delete()
            .in("chat_id", part);
        } catch {}
        try {
          await supabaseAdmin.from("chat_tags").delete().in("chat_id", part);
        } catch {}
      }
      try {
        await supabaseAdmin.from("chats").delete().in("id", chatIds);
      } catch {}
    }

    try {
      await supabaseAdmin.from("inbox_users").delete().eq("inbox_id", id);
    } catch {}
    try {
      await supabaseAdmin.from("inbox_secrets").delete().eq("inbox_id", id);
    } catch {}

    const { error: delErr } = await supabaseAdmin
      .from("inboxes")
      .delete()
      .eq("id", id);
    if (delErr) {
      console.error("Delete inbox error", delErr);
      return res
        .status(500)
        .json({
          error: delErr.message,
          details: (delErr as any)?.details || null,
          hint: (delErr as any)?.hint || null,
        });
    }

    try {
      io.emit("inbox:deleted", {
        inboxId: id,
        companyId: (inbox as any).company_id,
      });
    } catch {}
    return res.json({ ok: true });
  } catch (e: any) {
    return res.status(500).json({ error: e?.message || "inbox delete error" });
  }
});

// Manage inbox users: add/update permissions
app.post("/livechat/inboxes/:id/users", requireAuth, async (req: any, res) => {
  try {
    const { id } = req.params as { id: string };
    const schema = z.object({
      userId: z.string().min(1),
      can_read: z.boolean().optional().default(true),
      can_write: z.boolean().optional().default(true),
      can_manage: z.boolean().optional().default(false),
    });
    const parsed = schema.safeParse(req.body || {});
    if (!parsed.success)
      return res
        .status(400)
        .json({ error: "Dados inv?lidos", details: parsed.error.format() });
    const b = parsed.data as any;
    const { data: inbox } = await supabaseAdmin
      .from("inboxes")
      .select("id, company_id")
      .eq("id", id)
      .maybeSingle();
    if (!inbox) return res.status(404).json({ error: "Inbox n?o encontrada" });
    const { data: actor } = await supabaseAdmin
      .from("users")
      .select("id, role, company_id")
      .eq("user_id", req.user.id)
      .maybeSingle();
    if (!actor || (actor as any).company_id !== (inbox as any).company_id)
      return res.status(403).json({ error: "Proibido" });
    const role = ((actor as any).role || "").toString().toUpperCase();
    if (role === "AGENT") {
      const { data: link } = await supabaseAdmin
        .from("inbox_users")
        .select("can_manage")
        .eq("inbox_id", id)
        .eq("user_id", (actor as any).id)
        .maybeSingle();
      if (!link?.can_manage)
        return res
          .status(403)
          .json({ error: "Sem permiss?o para gerenciar usu?rios da inbox" });
    }
    // Ensure target user belongs to same company
    const { data: target } = await supabaseAdmin
      .from("users")
      .select("id, company_id")
      .eq("id", b.userId)
      .maybeSingle();
    if (!target || (target as any).company_id !== (inbox as any).company_id)
      return res
        .status(400)
        .json({ error: "Usu?rio inv?lido para esta empresa" });
    const { data, error } = await supabaseAdmin
      .from("inbox_users")
      .upsert(
        [
          {
            user_id: b.userId,
            inbox_id: id,
            can_read: b.can_read,
            can_write: b.can_write,
            can_manage: b.can_manage,
          },
        ],
        { onConflict: "user_id,inbox_id" },
      )
      .select("user_id, inbox_id, can_read, can_write, can_manage")
      .single();
    if (error) return res.status(500).json({ error: error.message });
    try {
      io.emit("inbox:users:updated", {
        inboxId: id,
        companyId: (inbox as any).company_id,
      });
    } catch {}
    return res.json(data);
  } catch (e: any) {
    return res
      .status(500)
      .json({ error: e?.message || "inbox users add error" });
  }
});

// Remove user from inbox
app.delete(
  "/livechat/inboxes/:id/users/:userId",
  requireAuth,
  async (req: any, res) => {
    try {
      const { id, userId } = req.params as { id: string; userId: string };
      const { data: inbox } = await supabaseAdmin
        .from("inboxes")
        .select("id, company_id")
        .eq("id", id)
        .maybeSingle();
      if (!inbox)
        return res.status(404).json({ error: "Inbox n?o encontrada" });
      const { data: actor } = await supabaseAdmin
        .from("users")
        .select("id, role, company_id")
        .eq("user_id", req.user.id)
        .maybeSingle();
      if (!actor || (actor as any).company_id !== (inbox as any).company_id)
        return res.status(403).json({ error: "Proibido" });
      const role = ((actor as any).role || "").toString().toUpperCase();
      if (role === "AGENT") {
        const { data: link } = await supabaseAdmin
          .from("inbox_users")
          .select("can_manage")
          .eq("inbox_id", id)
          .eq("user_id", (actor as any).id)
          .maybeSingle();
        if (!link?.can_manage)
          return res
            .status(403)
            .json({ error: "Sem permiss?o para gerenciar usu?rios da inbox" });
      }
      const { error } = await supabaseAdmin
        .from("inbox_users")
        .delete()
        .eq("inbox_id", id)
        .eq("user_id", userId);
      if (error) return res.status(500).json({ error: error.message });
      try {
        io.emit("inbox:users:updated", {
          inboxId: id,
          companyId: (inbox as any).company_id,
        });
      } catch {}
      return res.status(204).send();
    } catch (e: any) {
      return res
        .status(500)
        .json({ error: e?.message || "inbox users remove error" });
    }
  },
);
// Listar chats por inbox, status e busca
app.get("/livechat/chats", requireAuth, async (req, res) => {
  const inboxId = (req.query.inboxId as string) || undefined;
  const status = (req.query.status as string) || undefined;
  const q = (req.query.q as string) || undefined;
  const limit = req.query.limit ? Number(req.query.limit) : 20;
  const offset = req.query.offset ? Number(req.query.offset) : 0;

  let query = supabaseAdmin
    .from("chats")
    .select(
      "id, external_id, status, last_message, last_message_at, inbox_id, customer_id, assignee_agent",
      { count: "exact" },
    )
    .order("last_message_at", { ascending: false, nullsFirst: false });

  if (inboxId) query = query.eq("inbox_id", inboxId);
  if (status && status.toUpperCase() !== "ALL")
    query = query.eq("status", status);

  if (q) {
    // tenta buscar por last_message; se quiser expandir para customer name, use views/joins
    query = query.ilike("last_message", `%${q}%`);
  }

  const { data, error, count } = await query.range(
    offset,
    offset + Math.max(0, limit - 1),
  );
  if (error) return res.status(500).json({ error: error.message });

  const items = data || [];
  // Enrich with assigned agent from chats.assignee_agent (stores inbox_users.id)
  try {
    const linkIds = Array.from(
      new Set(
        (items as any[]).map((c) => (c as any).assignee_agent).filter(Boolean),
      ),
    );
    let userIdByLink: Record<string, string> = {};
    if (linkIds.length > 0) {
      const { data: links } = await supabaseAdmin
        .from("inbox_users")
        .select("id, user_id")
        .in("id", linkIds);
      for (const r of (links as any[]) || [])
        userIdByLink[(r as any).id] = (r as any).user_id;
      const userIds = Array.from(
        new Set(Object.values(userIdByLink).filter(Boolean)),
      );
      let usersById: Record<string, string> = {};
      if (userIds.length > 0) {
        const { data: u } = await supabaseAdmin
          .from("users")
          .select("id, name")
          .in("id", userIds);
        usersById = Object.fromEntries(
          ((u as any[]) || []).map((x) => [x.id, x.name || x.id]),
        );
      }
      for (const it of items as any[]) {
        const linkId = (it as any).assignee_agent || null;
        const uid = linkId ? userIdByLink[linkId] : null;
        (it as any).assigned_agent_id = linkId; // expose link id
        (it as any).assigned_agent_user_id = uid || null;
        (it as any).assigned_agent_name = uid ? usersById[uid] || null : null;
      }
    }
  } catch {}

  // Enrich with customer display (name/phone)
  try {
    const cids = Array.from(
      new Set((items as any[]).map((c) => c.customer_id).filter(Boolean)),
    );
    if (cids.length > 0) {
      const displayById: Record<
        string,
        { name: string | null; phone: string | null }
      > = {};
      async function loadDisplay(table: string, cols: string[]) {
        const sel = ["id", ...cols].join(",");
        const { data: rows } = await supabaseAdmin
          .from(table)
          .select(sel)
          .in("id", cids);
        for (const r of (rows as any[]) || []) {
          const name = (r as any).name || (r as any).title || null;
          const phone =
            (r as any).phone ||
            (r as any).cellphone ||
            (r as any).celular ||
            (r as any).telefone ||
            (r as any).contact ||
            null;
          displayById[(r as any).id] = { name, phone };
        }
      }
      await loadDisplay("customers", [
        "name",
        "phone",
        "cellphone",
        "contact",
      ]).catch(() => {});
      await loadDisplay("customers", [
        "name",
        "celular",
        "telefone",
        "contact",
      ]).catch(() => {});
      await loadDisplay("leads", ["name", "phone", "cellphone"]).catch(
        () => {},
      );
      for (const it of items as any[]) {
        const d = displayById[(it as any).customer_id];
        (it as any).customer_name = d?.name || null;
        (it as any).customer_phone = d?.phone || null;
      }
    }
  } catch {}

  // Enrich with last sender of last message
  try {
    const ids = (items as any[]).map((c) => (c as any).id);
    if (ids.length > 0) {
      const { data: msgs } = await supabaseAdmin
        .from("chat_messages")
        .select("chat_id, is_from_customer, sender_type, created_at")
        .in("chat_id", ids)
        .order("created_at", { ascending: false });
      const lastByChat: Record<string, string> = {};
      for (const r of (msgs as any[]) || []) {
        const cid = (r as any).chat_id as string;
        if (lastByChat[cid]) continue;
        const from =
          (r as any).sender_type ||
          ((r as any).is_from_customer ? "CUSTOMER" : "AGENT");
        lastByChat[cid] = from;
      }
      for (const it of items as any[]) {
        const cid = (it as any).id as string;
        if (lastByChat[cid]) (it as any).last_message_from = lastByChat[cid];
      }
    }
  } catch {}

  return res.json({ items, total: count ?? 0 });
});

// Criar chat
app.post("/livechat/chats", requireAuth, async (req, res) => {
  const { inboxId, customerId, externalId, initialMessage } = req.body || {};
  if (!inboxId || !customerId)
    return res
      .status(400)
      .json({ error: "inboxId e customerId sao obrigatorios" });

  const payload: any = {
    inbox_id: inboxId,
    customer_id: customerId,
    external_id: externalId || null,
    status: "OPEN",
  };

  // upsert pela unique (inbox_id, customer_id)
  const { data: chat, error: errUpsert } = await supabaseAdmin
    .from("chats")
    .upsert(payload, { onConflict: "inbox_id,customer_id" })
    .select("*")
    .single();
  if (errUpsert) return res.status(500).json({ error: errUpsert.message });

  if (initialMessage) {
    const { error: errMsg } = await supabaseAdmin.from("chat_messages").insert([
      {
        chat_id: chat.id,
        body: String(initialMessage),
        sender_type: "AGENT",
      },
    ]);
    if (errMsg) return res.status(500).json({ error: errMsg.message });
    await supabaseAdmin
      .from("chats")
      .update({
        last_message: String(initialMessage),
        last_message_at: new Date().toISOString(),
      })
      .eq("id", chat.id);
  }

  return res.status(201).json(chat);
});

// Detalhar chat (simples)
app.get("/livechat/chats/:id", requireAuth, async (req, res) => {
  const { id } = req.params as { id: string };
  const { data, error } = await supabaseAdmin
    .from("chats")
    .select("*")
    .eq("id", id)
    .maybeSingle();
  if (error) return res.status(500).json({ error: error.message });
  if (!data) return res.status(404).json({ error: "Chat nao encontrado" });
  return res.json(data);
});

// Atualizar status do chat
app.put("/livechat/chats/:id/status", requireAuth, async (req, res) => {
  const { id } = req.params as { id: string };
  const { status } = req.body || {};
  if (!status) return res.status(400).json({ error: "status obrigatorio" });
  const { data, error } = await supabaseAdmin
    .from("chats")
    .update({ status })
    .eq("id", id)
    .select("*")
    .single();
  if (error) return res.status(500).json({ error: error.message });
  return res.json(data);
});

// Listar mensagens do chat
app.get("/livechat/chats/:id/messages", requireAuth, async (req, res) => {
  const { id } = req.params as { id: string };
  const limit = req.query.limit ? Number(req.query.limit) : 50;
  const before = (req.query.before as string) || undefined;
  try {
    let query = supabaseAdmin
      .from("chat_messages")
      .select(
        "id, chat_id, content, is_from_customer, sender_id, created_at, type, view_status",
      )
      .eq("chat_id", id)
      .order("created_at", { ascending: true })
      .limit(limit);
    if (before) query = query.lt("created_at", before);

    const { data, error } = await query;
    if (error && (error as any).code === "42P01") {
      // Tabela n?o existe ainda
      return res.json([]);
    }
    if (error) {
      console.error("/livechat/chats/:id/messages error", { id, error });
      return res.status(500).json({ error: error.message });
    }
    const mappedChat = (data || []).map((r: any) => ({
      id: r.id,
      chat_id: r.chat_id,
      body: r.content,
      sender_type: r.is_from_customer ? "CUSTOMER" : "AGENT",
      sender_id: r.sender_id || null,
      created_at: r.created_at,
      view_status: r.view_status || null,
      type: r.type || "TEXT",
      is_private: false,
    }));

    // Tamb?m incluir mensagens privadas, se existirem, para este chat
    let mappedPrivate: any[] = [];
    try {
      const { data: privChat } = await supabaseAdmin
        .from("private_chats")
        .select("id")
        .eq("chat_id", id)
        .maybeSingle();
      if (privChat?.id) {
        const { data: privMsgs } = await supabaseAdmin
          .from("private_messages")
          .select("id, content, private_chat_id, sender_id, created_at")
          .eq("private_chat_id", privChat.id)
          .order("created_at", { ascending: true });
        // carregar nomes de remetentes
        const senderIds = Array.from(
          new Set(
            (privMsgs || []).map((r: any) => r.sender_id).filter(Boolean),
          ),
        );
        let nameMap: Record<string, string> = {};
        if (senderIds.length > 0) {
          const { data: usersList } = await supabaseAdmin
            .from("users")
            .select("id, name")
            .in("id", senderIds);
          for (const u of usersList || [])
            nameMap[(u as any).id] = (u as any).name || (u as any).id;
        }
        mappedPrivate = (privMsgs || []).map((r: any) => ({
          id: r.id,
          chat_id: id,
          body: r.content,
          sender_type: "AGENT",
          sender_id: r.sender_id || null,
          created_at: r.created_at,
          view_status: null,
          type: "PRIVATE",
          is_private: true,
          sender_name: r.sender_id ? nameMap[r.sender_id] || null : null,
        }));
      }
    } catch (_) {
      // ignore
    }

    // Merge e ordenar por created_at
    const combined = [...mappedChat, ...mappedPrivate].sort(
      (a, b) =>
        new Date(a.created_at).getTime() - new Date(b.created_at).getTime(),
    );

    return res.json(combined);
  } catch (e: any) {
    console.error("/livechat/chats/:id/messages catch", { id, err: e });
    return res.status(500).json({ error: e?.message || "messages error" });
  }
});

// ===== Tags (labels) management =====
// List tags of current user's company
app.get("/livechat/tags", requireAuth, async (req: any, res) => {
  try {
    const authUserId = req.user.id as string;
    const { data: urow, error: errU } = await supabaseAdmin
      .from("users")
      .select("company_id")
      .eq("user_id", authUserId)
      .maybeSingle();
    if (errU) return res.status(500).json({ error: errU.message });
    if (!urow?.company_id)
      return res.status(404).json({ error: "Usu?rio sem company_id" });
    const { data, error } = await supabaseAdmin
      .from("tags")
      .select("id, name, color, created_at, updated_at")
      .eq("company_id", urow.company_id)
      .order("name", { ascending: true });
    if (error) return res.status(500).json({ error: error.message });
    return res.json(data || []);
  } catch (e: any) {
    return res.status(500).json({ error: e?.message || "tags list error" });
  }
});

// ===== Livechat Contacts (customers) =====
// List contacts of current user's company (fallback to customers if customers not available)
app.get("/livechat/contacts", requireAuth, async (req: any, res) => {
  try {
    const authUserId = req.user.id as string;
    const { data: urow, error: errU } = await supabaseAdmin
      .from("users")
      .select("company_id")
      .eq("user_id", authUserId)
      .maybeSingle();
    if (errU) return res.status(500).json({ error: errU.message });
    if (!urow?.company_id)
      return res.status(404).json({ error: "Usu?rio sem company_id" });

    const q = (req.query.q as string | undefined)?.trim();
    const city = (req.query.city as string | undefined)?.trim();
    const uf = (req.query.uf as string | undefined)?.trim();
    const limit = req.query.limit ? Number(req.query.limit) : 20;
    const offset = req.query.offset ? Number(req.query.offset) : 0;

    async function listFrom(table: string, fields: string[]) {
      let query = supabaseAdmin
        .from(table)
        .select(fields.join(","), { count: "exact" })
        .eq("company_id", (urow as any).company_id)
        .order("updated_at", { ascending: false });
      if (q) query = query.ilike("name", `%${q}%`);
      // best-effort filters across common columns
      if (city) {
        const cityCol = table === "customers" ? "city" : "cidade";
        try {
          query = query.ilike(cityCol, `%${city}%`);
        } catch {}
      }
      if (uf) {
        const ufCol = "uf";
        try {
          query = query.ilike(ufCol, `%${uf}%`);
        } catch {}
      }
      const { data, error, count } = await query.range(
        offset,
        offset + Math.max(0, limit - 1),
      );
      if (error) throw error;
      const items = (data || []).map((r: any) => ({
        id: r.id,
        name: r.name || r.title || r.id,
        phone: r.phone || r.cellphone || r.celular || r.telefone || null,
        email: r.email || null,
        instagram: r.instagram || null,
        facebook: r.facebook || null,
        twitter: r.twitter || null,
        telegram: r.telegram || null,
        website: r.website || r.site || null,
        notes: r.notes || r.observacoes || null,
        updated_at: r.updated_at || null,
      }));
      return { items, total: count ?? 0 };
    }

    try {
      return res.json(
        await listFrom("customers", [
          "id",
          "name",
          "phone",
          "cellphone",
          "email",
          "instagram",
          "facebook",
          "twitter",
          "telegram",
          "website",
          "site",
          "notes",
          "observacoes",
          "updated_at",
          "company_id",
          "city",
          "cidade",
          "uf",
        ]),
      );
    } catch (e: any) {
      return res
        .status(500)
        .json({ error: e?.message || "contacts list error" });
    }
  } catch (e: any) {
    return res.status(500).json({ error: e?.message || "contacts list error" });
  }
});

// Get a single contact
app.get("/livechat/contacts/:id", requireAuth, async (req: any, res) => {
  const { id } = req.params as { id: string };
  try {
    const { data, error } = await supabaseAdmin
      .from("customers")
      .select("*")
      .eq("id", id)
      .maybeSingle();
    if (!error && data) {
      let assigned_agent: string | null = null;
      let assigned_agent_name: string | null = null;
      let lead_id: string | null = null;
      try {
        // tenta ler assigned_agent (se coluna existir)
        assigned_agent = (data as any).assigned_agent ?? null;
        if (assigned_agent === undefined) {
          const { data: row2 } = await supabaseAdmin
            .from("customers")
            .select("assigned_agent")
            .eq("id", id)
            .maybeSingle();
          assigned_agent = (row2 as any)?.assigned_agent ?? null;
        }
        if (assigned_agent) {
          const { data: u } = await supabaseAdmin
            .from("users")
            .select("id, name")
            .eq("id", assigned_agent)
            .maybeSingle();
          assigned_agent_name = (u as any)?.name || null;
        }
        // tentar descobrir lead vinculado
        lead_id = (data as any).lead_id || null;
        if (!lead_id) {
          const { data: l } = await supabaseAdmin
            .from("leads")
            .select("id")
            .eq("customer_id", id)
            .maybeSingle();
          lead_id = (l as any)?.id || null;
        }
      } catch {}
      return res.json({
        id: (data as any).id,
        name: (data as any).name || (data as any).title || (data as any).id,
        phone:
          (data as any).phone ||
          (data as any).cellphone ||
          (data as any).celular ||
          (data as any).telefone ||
          null,
        email: (data as any).email || null,
        instagram: (data as any).instagram || null,
        facebook: (data as any).facebook || null,
        twitter: (data as any).twitter || null,
        telegram: (data as any).telegram || null,
        website: (data as any).website || (data as any).site || null,
        notes: (data as any).notes || (data as any).observacoes || null,
        assigned_agent: assigned_agent || null,
        assigned_agent_name,
        lead_id,
      });
    }
  } catch {}
  try {
    const { data, error } = await supabaseAdmin
      .from("customers")
      .select("*")
      .eq("id", id)
      .maybeSingle();
    if (error) return res.status(500).json({ error: error.message });
    if (!data) return res.status(404).json({ error: "Contato n?o encontrado" });
    let assigned_agent: string | null = null;
    let assigned_agent_name: string | null = null;
    try {
      // tenta ler assigned_agent (se coluna existir)
      assigned_agent = (data as any).assigned_agent ?? null;
      if (assigned_agent === undefined) {
        const { data: row2 } = await supabaseAdmin
          .from("customers")
          .select("assigned_agent")
          .eq("id", id)
          .maybeSingle();
        assigned_agent = (row2 as any)?.assigned_agent ?? null;
      }
      if (assigned_agent) {
        const { data: u } = await supabaseAdmin
          .from("users")
          .select("id, name")
          .eq("id", assigned_agent)
          .maybeSingle();
        assigned_agent_name = (u as any)?.name || null;
      }
    } catch {}
    return res.json({
      id: (data as any).id,
      name: (data as any).name || (data as any).title || (data as any).id,
      phone:
        (data as any).phone ||
        (data as any).cellphone ||
        (data as any).celular ||
        (data as any).telefone ||
        null,
      email: (data as any).email || null,
      instagram: (data as any).instagram || null,
      facebook: (data as any).facebook || null,
      twitter: (data as any).twitter || null,
      telegram: (data as any).telegram || null,
      website: (data as any).website || (data as any).site || null,
      notes: (data as any).notes || (data as any).observacoes || null,
      assigned_agent: assigned_agent || null,
      assigned_agent_name,
    });
  } catch (e: any) {
    // Fallback final: leads, caso o id seja de lead
    try {
      const { data } = await supabaseAdmin
        .from("leads")
        .select("*")
        .eq("id", id)
        .maybeSingle();
      if (!data)
        return res
          .status(500)
          .json({ error: e?.message || "contact get error" });
      return res.json({
        id: (data as any).id,
        name: (data as any).name || (data as any).title || (data as any).id,
        phone: (data as any).phone || (data as any).cellphone || null,
        email: (data as any).email || null,
        instagram: (data as any).instagram || null,
        facebook: (data as any).facebook || null,
        twitter: (data as any).twitter || null,
        telegram: (data as any).telegram || null,
        website: (data as any).website || (data as any).site || null,
        notes: (data as any).notes || (data as any).observacoes || null,
        assigned_agent: (data as any).assigned_to_id || null,
        assigned_agent_name: null,
      });
    } catch {
      return res.status(500).json({ error: e?.message || "contact get error" });
    }
  }
});

// Create contact
app.post("/livechat/contacts", requireAuth, async (req: any, res) => {
  try {
    const authUserId = req.user.id as string;
    const { data: urow, error: errU } = await supabaseAdmin
      .from("users")
      .select("company_id")
      .eq("user_id", authUserId)
      .maybeSingle();
    if (errU) return res.status(500).json({ error: errU.message });
    if (!urow?.company_id)
      return res.status(404).json({ error: "Usu?rio sem company_id" });

    const body = req.body || {};
    const payload = {
      company_id: (urow as any).company_id,
      name: body.name ?? null,
      phone: body.phone ?? null,
      email: body.email ?? null,
      instagram: body.instagram ?? null,
      facebook: body.facebook ?? null,
      twitter: body.twitter ?? null,
      telegram: body.telegram ?? null,
      website: body.website ?? null,
      notes: body.notes ?? null,
    } as any;
    try {
      const { data, error } = await supabaseAdmin
        .from("customers")
        .insert([payload])
        .select("id")
        .single();
      if (error) throw error;
      return res.status(201).json({ id: (data as any).id });
    } catch (e) {
      // fallback legacy table with column mapping
      const legacy = {
        company_id: (urow as any).company_id,
        name: body.name ?? null,
        celular: body.phone ?? null,
        telefone: null,
        email: body.email ?? null,
        instagram: body.instagram ?? null,
        facebook: body.facebook ?? null,
        twitter: body.twitter ?? null,
        telegram: body.telegram ?? null,
        site: body.website ?? null,
        observacoes: body.notes ?? null,
      } as any;
      try {
        const { data, error } = await supabaseAdmin
          .from("customers")
          .insert([legacy])
          .select("id")
          .single();
        if (error) throw error;
        return res.status(201).json({ id: (data as any).id });
      } catch (err: any) {
        return res
          .status(500)
          .json({ error: err?.message || "contact create error" });
      }
    }
  } catch (e: any) {
    return res
      .status(500)
      .json({ error: e?.message || "contact create error" });
  }
});

// Update contact
app.put("/livechat/contacts/:id", requireAuth, async (req: any, res) => {
  const { id } = req.params as { id: string };
  const body = req.body || {};
  const payload = {
    name: body.name ?? undefined,
    phone: body.phone ?? undefined,
    email: body.email ?? undefined,
    instagram: body.instagram ?? undefined,
    facebook: body.facebook ?? undefined,
    twitter: body.twitter ?? undefined,
    telegram: body.telegram ?? undefined,
    website: body.website ?? undefined,
    notes: body.notes ?? undefined,
  } as any;
  try {
    const { data, error } = await supabaseAdmin
      .from("customers")
      .update(payload)
      .eq("id", id)
      .select("id")
      .maybeSingle();
    if (!error) return res.json({ id: (data as any)?.id ?? id });
  } catch {}
  try {
    const legacy = {
      name: body.name ?? undefined,
      celular: body.phone ?? undefined,
      email: body.email ?? undefined,
      instagram: body.instagram ?? undefined,
      facebook: body.facebook ?? undefined,
      twitter: body.twitter ?? undefined,
      telegram: body.telegram ?? undefined,
      site: body.website ?? undefined,
      observacoes: body.notes ?? undefined,
    } as any;
    const { data, error } = await supabaseAdmin
      .from("customers")
      .update(legacy)
      .eq("id", id)
      .select("id")
      .maybeSingle();
    if (error) return res.status(500).json({ error: error.message });
    return res.json({ id: (data as any)?.id ?? id });
  } catch (e: any) {
    return res
      .status(500)
      .json({ error: e?.message || "contact update error" });
  }
});

// Create tag; optionally also create a kanban column in the company's default board
app.post("/livechat/tags", requireAuth, async (req: any, res) => {
  const authUserId = req.user.id as string;
  const schema = z.object({
    name: z.string().min(1),
    color: z.string().min(1).optional(),
    createColumn: z.boolean().optional(),
  });
  const parsed = schema.safeParse(req.body || {});
  if (!parsed.success)
    return res.status(400).json({ error: parsed.error.message });
  const { name, color, createColumn = false } = parsed.data;

  // Load current user company and role
  const { data: urow, error: errU } = await supabaseAdmin
    .from("users")
    .select("company_id, role")
    .eq("user_id", authUserId)
    .maybeSingle();
  if (errU) return res.status(500).json({ error: errU.message });
  if (!urow?.company_id)
    return res.status(404).json({ error: "Usu?rio sem company_id" });
  const role = (urow as any).role as string | null;
  const allowed =
    role === "ADMIN" || role === "MANAGER" || role === "SUPERVISOR";
  if (!allowed)
    return res.status(403).json({ error: "Sem permiss?o para criar labels" });

  // Create tag
  const { data: tag, error: errTag } = await supabaseAdmin
    .from("tags")
    .insert([
      { name, color: color || null, company_id: (urow as any).company_id },
    ])
    .select("id, name, color")
    .single();
  if (errTag) return res.status(400).json({ error: errTag.message });

  let createdColumn: any = null;
  if (createColumn) {
    // Find default board for company
    const { data: board } = await supabaseAdmin
      .from("kanban_boards")
      .select("id, is_default, created_at")
      .eq("company_id", (urow as any).company_id)
      .order("is_default", { ascending: false })
      .order("created_at", { ascending: true })
      .limit(1)
      .maybeSingle();
    if (board?.id) {
      // Determine next position
      const { data: last } = await supabaseAdmin
        .from("kanban_columns")
        .select("position")
        .eq("kanban_board_id", (board as any).id)
        .order("position", { ascending: false })
        .limit(1)
        .maybeSingle();
      const nextPos = ((last as any)?.position || 0) + 1;
      const { data: col } = await supabaseAdmin
        .from("kanban_columns")
        .insert([
          {
            name,
            color: color || null,
            position: nextPos,
            kanban_board_id: (board as any).id,
          },
        ])
        .select("id, name, color, position")
        .single();
      createdColumn = col || null;
    }
  }

  return res.status(201).json({ tag, column: createdColumn });
});

// Enviar mensagem
app.post("/livechat/chats/:id/messages", requireAuth, async (req: any, res) => {
  const { id } = req.params as { id: string };
  const { text, senderType = "AGENT" } = req.body || {};
  if (!text) return res.status(400).json({ error: "text obrigatorio" });

  const isFromCustomer = String(senderType).toUpperCase() === "CUSTOMER";
  const nowIso = new Date().toISOString();
  const { data: inserted, error } = await supabaseAdmin
    .from("chat_messages")
    .insert([
      {
        chat_id: id,
        content: String(text),
        type: "TEXT",
        is_from_customer: isFromCustomer,
        sender_id: req.user?.id || null,
        created_at: nowIso,
        view_status: "Sent",
      },
    ])
    .select(
      "id, chat_id, content, is_from_customer, sender_id, created_at, view_status, type",
    )
    .single();
  if (error) return res.status(500).json({ error: error.message });

  await supabaseAdmin
    .from("chats")
    .update({ last_message: String(text), last_message_at: nowIso })
    .eq("id", id);

  const mapped = {
    id: inserted.id,
    chat_id: inserted.chat_id,
    body: inserted.content,
    sender_type: inserted.is_from_customer ? "CUSTOMER" : "AGENT",
    sender_id: inserted.sender_id || null,
    created_at: inserted.created_at,
    view_status: inserted.view_status || null,
    type: inserted.type || "TEXT",
    is_private: false,
  };

  // Emitir tamb?m via socket para clientes conectados
  io.to(`chat:${id}`).emit("message:new", mapped);
  io.emit("chat:updated", {
    chatId: id,
    last_message: String(text),
    last_message_at: nowIso,
    last_message_from: mapped.sender_type,
  });

  return res.status(201).json(mapped);
});

// Enviar anexo/?udio/arquivo (payload base64 JSON)
app.post(
  "/livechat/chats/:id/messages/file",
  requireAuth,
  async (req: any, res) => {
    const { id } = req.params as { id: string };
    const { filename, mime, data } = (req.body || {}) as {
      filename?: string;
      mime?: string;
      data?: string;
    };
    if (!filename || !data)
      return res.status(400).json({ error: "filename e data obrigatorios" });
    const contentType = mime || "application/octet-stream";
    try {
      const buffer = Buffer.from(
        String(data).replace(/^data:[^;]+;base64,/, ""),
        "base64",
      );
      const ext = filename.includes(".") ? filename.split(".").pop() : "bin";
      const path = `${id}/${Date.now()}_${Math.random().toString(36).slice(2)}.${ext}`;
      // Garante bucket
      try {
        await (supabaseAdmin as any).storage.createBucket("chat-uploads", {
          public: true,
        });
      } catch {}
      const { data: up, error: upErr } = await supabaseAdmin.storage
        .from("chat-uploads")
        .upload(path, buffer, { contentType, upsert: false });
      if (upErr) return res.status(500).json({ error: upErr.message });
      const pub = supabaseAdmin.storage
        .from("chat-uploads")
        .getPublicUrl(up!.path);
      const url = (pub as any)?.data?.publicUrl || null;
      const nowIso = new Date().toISOString();
      const kind = contentType.startsWith("image/")
        ? "IMAGE"
        : contentType.startsWith("audio/")
          ? "AUDIO"
          : "FILE";

      const { data: inserted, error } = await supabaseAdmin
        .from("chat_messages")
        .insert([
          {
            chat_id: id,
            content: String(url || filename),
            type: kind,
            is_from_customer: false,
            sender_id: req.user?.id || null,
            created_at: nowIso,
            view_status: "Sent",
          },
        ])
        .select(
          "id, chat_id, content, is_from_customer, sender_id, created_at, view_status, type",
        )
        .single();
      if (error) return res.status(500).json({ error: error.message });

      await supabaseAdmin
        .from("chats")
        .update({
          last_message: `[Arquivo] ${filename}`,
          last_message_at: nowIso,
        })
        .eq("id", id);

      const mapped = {
        id: inserted.id,
        chat_id: inserted.chat_id,
        body: inserted.content,
        sender_type: inserted.is_from_customer ? "CUSTOMER" : "AGENT",
        sender_id: inserted.sender_id || null,
        created_at: inserted.created_at,
        view_status: inserted.view_status || null,
        type: inserted.type || kind,
        is_private: false,
      };

      io.to(`chat:${id}`).emit("message:new", mapped);
      io.emit("chat:updated", {
        chatId: id,
        last_message: `[Arquivo] ${filename}`,
        last_message_at: nowIso,
        last_message_from: mapped.sender_type,
      });
      return res.status(201).json(mapped);
    } catch (e: any) {
      return res.status(500).json({ error: e?.message || "upload error" });
    }
  },
);

// Listar mensagens privadas separadamente (usado pelo modal)
app.get(
  "/livechat/chats/:id/private/messages",
  requireAuth,
  async (req: any, res) => {
    const { id } = req.params as { id: string };
    try {
      const { data: privChat, error: errPc } = await supabaseAdmin
        .from("private_chats")
        .select("id")
        .eq("chat_id", id)
        .maybeSingle();
      if (errPc) return res.status(500).json({ error: errPc.message });
      if (!privChat?.id) return res.json([]);
      const { data, error } = await supabaseAdmin
        .from("private_messages")
        .select("id, content, sender_id, created_at")
        .eq("private_chat_id", privChat.id)
        .order("created_at", { ascending: true });
      if (error) return res.status(500).json({ error: error.message });
      // carregar nomes
      const senderIds = Array.from(
        new Set((data || []).map((r: any) => r.sender_id).filter(Boolean)),
      );
      let nameMap: Record<string, string> = {};
      if (senderIds.length > 0) {
        const { data: usersList } = await supabaseAdmin
          .from("users")
          .select("id, name")
          .in("id", senderIds);
        for (const u of usersList || [])
          nameMap[(u as any).id] = (u as any).name || (u as any).id;
      }
      return res.json(
        (data || []).map((r: any) => ({
          id: r.id,
          chat_id: id,
          body: r.content,
          sender_type: "AGENT",
          sender_id: r.sender_id || null,
          created_at: r.created_at,
          view_status: null,
          type: "PRIVATE",
          is_private: true,
          sender_name: r.sender_id ? nameMap[r.sender_id] || null : null,
        })),
      );
    } catch (e: any) {
      return res
        .status(500)
        .json({ error: e?.message || "private list error" });
    }
  },
);

// Enviar mensagem privada (cria private_chat se necess?rio)
app.post(
  "/livechat/chats/:id/private/messages",
  requireAuth,
  async (req: any, res) => {
    const { id } = req.params as { id: string };
    const { text } = (req.body || {}) as { text?: string };
    if (!text) return res.status(400).json({ error: "text obrigatorio" });
    try {
      // resolver users.id local a partir do auth user_id
      let localUserId: string | null = null;
      try {
        const { data: urow } = await supabaseAdmin
          .from("users")
          .select("id")
          .eq("user_id", req.user.id)
          .maybeSingle();
        localUserId = (urow as any)?.id || null;
      } catch {}

      // garantir private_chat
      let privateChatId: string | null = null;
      const { data: existing } = await supabaseAdmin
        .from("private_chats")
        .select("id")
        .eq("chat_id", id)
        .maybeSingle();
      if (existing?.id) privateChatId = existing.id;
      else {
        const { data: created, error: errCreate } = await supabaseAdmin
          .from("private_chats")
          .insert([{ chat_id: id, is_active: true }])
          .select("id")
          .single();
        if (errCreate)
          return res.status(500).json({ error: errCreate.message });
        privateChatId = (created as any)?.id || null;
      }
      if (!privateChatId)
        return res.status(500).json({ error: "Falha ao criar private_chat" });

      const nowIso = new Date().toISOString();
      const { data: inserted, error } = await supabaseAdmin
        .from("private_messages")
        .insert([
          {
            content: String(text),
            private_chat_id: privateChatId,
            sender_id: localUserId || req.user.id,
            created_at: nowIso,
          },
        ])
        .select("id, content, sender_id, created_at")
        .single();
      if (error) return res.status(500).json({ error: error.message });

      // emitir no mesmo canal do chat para aparecer no feed
      let senderName: string | null = null;
      if (localUserId) {
        try {
          const { data: u } = await supabaseAdmin
            .from("users")
            .select("name")
            .eq("id", localUserId)
            .maybeSingle();
          senderName = (u as any)?.name || null;
        } catch {}
      }
      const mapped = {
        id: inserted.id,
        chat_id: id,
        body: inserted.content,
        sender_type: "AGENT",
        sender_id: inserted.sender_id || null,
        created_at: inserted.created_at,
        view_status: null,
        type: "PRIVATE",
        is_private: true,
        sender_name: senderName,
      };
      io.to(`chat:${id}`).emit("message:new", mapped);
      return res.status(201).json(mapped);
    } catch (e: any) {
      return res
        .status(500)
        .json({ error: e?.message || "private send error" });
    }
  },
);

// Gerenciar tags do chat (set completa)
app.put("/livechat/chats/:id/tags", requireAuth, async (req, res) => {
  const { id } = req.params as { id: string };
  const { tags } = req.body || {};
  const tagIdsRaw: string[] = Array.isArray(tags) ? tags : [];
  const tagIds = Array.from(new Set((tagIdsRaw || []).filter(Boolean)));

  const { error: errDel } = await supabaseAdmin
    .from("chat_tags")
    .delete()
    .eq("chat_id", id);
  if (errDel) return res.status(500).json({ error: errDel.message });
  if (tagIds.length === 0) {
    try {
      io.to(`chat:${id}`).emit("chat:tags", { chatId: id, tags: [] });
    } catch {}
    return res.json({ ok: true, count: 0 });
  }

  try {
    const authUserId = (req as any).user.id as string;
    const { data: urow } = await supabaseAdmin
      .from("users")
      .select("company_id")
      .eq("user_id", authUserId)
      .maybeSingle();
    const companyId = (urow as any)?.company_id;

    let boardId: string | null = null;
    if (companyId) {
      const { data: board } = await supabaseAdmin
        .from("kanban_boards")
        .select("id, is_default, created_at")
        .eq("company_id", companyId)
        .order("is_default", { ascending: false })
        .order("created_at", { ascending: true })
        .limit(1)
        .maybeSingle();
      boardId = (board as any)?.id || null;
    }

    const { data: tagRows } = await supabaseAdmin
      .from("tags")
      .select("id, name, color")
      .in("id", tagIds);
    const rowsToInsert: {
      chat_id: string;
      tag_id: string;
      kanban_colum_id: string;
    }[] = [];
    const insertedTags = new Set<string>();
    for (const t of (tagRows as any[]) || []) {
      const tagId = (t as any)?.id as string | undefined;
      if (!tagId || insertedTags.has(tagId)) continue;
      insertedTags.add(tagId);

      let columnId: string | null = null;
      if (boardId) {
        const { data: col } = await supabaseAdmin
          .from("kanban_columns")
          .select("id")
          .eq("kanban_board_id", boardId)
          .eq("name", (t as any).name)
          .maybeSingle();
        columnId = (col as any)?.id || null;
        if (!columnId) {
          const { data: last } = await supabaseAdmin
            .from("kanban_columns")
            .select("position")
            .eq("kanban_board_id", boardId)
            .order("position", { ascending: false })
            .limit(1)
            .maybeSingle();
          const nextPos = ((last as any)?.position || 0) + 1;
          const { data: created } = await supabaseAdmin
            .from("kanban_columns")
            .insert([
              {
                name: (t as any).name,
                color: (t as any).color || null,
                position: nextPos,
                kanban_board_id: boardId,
              },
            ])
            .select("id")
            .single();
          columnId = (created as any)?.id || null;
        }
      }
      if (!columnId) {
        return res
          .status(400)
          .json({
            error: "Nenhuma coluna/board disponvel para vincular a tag",
          });
      }
      rowsToInsert.push({
        chat_id: id,
        tag_id: tagId,
        kanban_colum_id: columnId,
      });
    }

    if (rowsToInsert.length === 0) {
      try {
        io.to(`chat:${id}`).emit("chat:tags", { chatId: id, tags: [] });
      } catch {}
      return res.json({ ok: true, count: 0 });
    }

    const { error: insertErr } = await supabaseAdmin
      .from("chat_tags")
      .insert(rowsToInsert);
    if (insertErr) return res.status(500).json({ error: insertErr.message });

    const { data: currentRows } = await supabaseAdmin
      .from("chat_tags")
      .select("tag_id")
      .eq("chat_id", id);
    const savedTagIds = ((currentRows as any[]) || []).map((r) => (r as any).tag_id);
    try {
      io.to(`chat:${id}`).emit("chat:tags", { chatId: id, tags: savedTagIds });
    } catch {}
    return res.json({ ok: true, count: savedTagIds.length });
  } catch (e: any) {
    return res.status(500).json({ error: e?.message || "tags set error" });
  }
});

app.post("/livechat/chats/:id/tags", requireAuth, async (req, res) => {
  const { id } = req.params as { id: string };
  const { tagId } = (req.body || {}) as { tagId?: string };
  if (!tagId) return res.status(400).json({ error: "tagId obrigatorio" });

  try {
    const { data: existing } = await supabaseAdmin
      .from("chat_tags")
      .select("id")
      .eq("chat_id", id)
      .eq("tag_id", tagId)
      .maybeSingle();
    if (existing?.id) {
      const { data: currentRows } = await supabaseAdmin
        .from("chat_tags")
        .select("tag_id")
        .eq("chat_id", id);
      const tags = ((currentRows as any[]) || []).map((r) => (r as any).tag_id);
      try {
        io.to(`chat:${id}`).emit("chat:tags", { chatId: id, tags });
      } catch {}
      return res.json({ ok: true, count: tags.length });
    }

    const authUserId = (req as any).user.id as string;
    const { data: urow } = await supabaseAdmin
      .from("users")
      .select("company_id")
      .eq("user_id", authUserId)
      .maybeSingle();
    const companyId = (urow as any)?.company_id;

    const { data: tagRow } = await supabaseAdmin
      .from("tags")
      .select("id, name, color")
      .eq("id", tagId)
      .maybeSingle();
    if (!tagRow) return res.status(404).json({ error: "Tag nao encontrada" });

    let boardId: string | null = null;
    if (companyId) {
      const { data: board } = await supabaseAdmin
        .from("kanban_boards")
        .select("id, is_default, created_at")
        .eq("company_id", companyId)
        .order("is_default", { ascending: false })
        .order("created_at", { ascending: true })
        .limit(1)
        .maybeSingle();
      boardId = (board as any)?.id || null;
    }

    let columnId: string | null = null;
    if (boardId) {
      const { data: col } = await supabaseAdmin
        .from("kanban_columns")
        .select("id")
        .eq("kanban_board_id", boardId)
        .eq("name", (tagRow as any).name)
        .maybeSingle();
      columnId = (col as any)?.id || null;
      if (!columnId) {
        const { data: last } = await supabaseAdmin
          .from("kanban_columns")
          .select("position")
          .eq("kanban_board_id", boardId)
          .order("position", { ascending: false })
          .limit(1)
          .maybeSingle();
        const nextPos = ((last as any)?.position || 0) + 1;
        const { data: created } = await supabaseAdmin
          .from("kanban_columns")
          .insert([
            {
              name: (tagRow as any).name,
              color: (tagRow as any).color || null,
              position: nextPos,
              kanban_board_id: boardId,
            },
          ])
          .select("id")
          .single();
        columnId = (created as any)?.id || null;
      }
    }
    if (!columnId) {
      return res
        .status(400)
        .json({ error: "Nenhuma coluna/board disponvel para vincular a tag" });
    }

    const { error: insertErr } = await supabaseAdmin
      .from("chat_tags")
      .insert([
        {
          chat_id: id,
          tag_id: tagId,
          kanban_colum_id: columnId,
        },
      ]);


    const { data: currentRows } = await supabaseAdmin
      .from("chat_tags")
      .select("tag_id")
      .eq("chat_id", id);
    const tags = ((currentRows as any[]) || []).map((r) => (r as any).tag_id);
    try {
      io.to(`chat:${id}`).emit("chat:tags", { chatId: id, tags });
    } catch {}
    return res.status(201).json({ ok: true, count: tags.length });
  } catch (e: any) {
    return res.status(500).json({ error: e?.message || "tag add error" });
  }
});
app.get("/livechat/chats/:id/tags", requireAuth, async (req, res) => {
  const { id } = req.params as { id: string };
  try {
    const { data, error } = await supabaseAdmin
      .from("chat_tags")
      .select("tag_id")
      .eq("chat_id", id);
    if (error) return res.status(500).json({ error: error.message });
    return res.json(((data as any[]) || []).map((r) => (r as any).tag_id));
  } catch (e: any) {
    return res.status(500).json({ error: e?.message || "tags list error" });
  }
});

app.delete("/livechat/chats/:id/tags/:tagId", requireAuth, async (req, res) => {
  const { id, tagId } = req.params as { id: string; tagId: string };
  try {
    const { error } = await supabaseAdmin
      .from("chat_tags")
      .delete()
      .eq("chat_id", id)
      .eq("tag_id", tagId);
    if (error) return res.status(500).json({ error: error.message });
    const { data: remaining } = await supabaseAdmin
      .from("chat_tags")
      .select("tag_id")
      .eq("chat_id", id);
    const nextIds = ((remaining as any[]) || []).map((r) => (r as any).tag_id);
    try {
      io.to(`chat:${id}`).emit("chat:tags", { chatId: id, tags: nextIds });
    } catch {}
    return res.json({ ok: true, count: nextIds.length });
  } catch (e: any) {
    return res.status(500).json({ error: e?.message || "tag delete error" });
  }
});

// ===== CRM Contacts (Leads) =====
// List leads as contacts with social fields
app.get("/livechat/crm/contacts", requireAuth, async (req: any, res) => {
  try {
    const authUserId = req.user.id as string;
    const { data: urow } = await supabaseAdmin
      .from("users")
      .select("company_id")
      .eq("user_id", authUserId)
      .maybeSingle();
    const companyId = (urow as any)?.company_id || null;

    const q = (req.query.q as string | undefined)?.trim();
    const city = (req.query.city as string | undefined)?.trim();
    const uf = (req.query.uf as string | undefined)?.trim();
    const limit = req.query.limit ? Number(req.query.limit) : 20;
    const offset = req.query.offset ? Number(req.query.offset) : 0;

    let query = supabaseAdmin
      .from("leads")
      .select("*", { count: "exact" })
      .order("updated_at", { ascending: false });
    try {
      if (companyId) query = query.eq("company_id", companyId);
    } catch {}
    if (q) query = query.ilike("name", `%${q}%`);
    if (city) query = query.ilike("city", `%${city}%`);
    if (uf) query = query.ilike("state", `%${uf}%`);

    const { data, error, count } = await query.range(
      offset,
      offset + Math.max(0, limit - 1),
    );
    if (error) return res.status(500).json({ error: error.message });
    const items = (data || []).map((r: any) => ({
      id: r.id,
      name: r.name || r.id,
      phone: r.phone ?? null,
      email: r.email ?? null,
      instagram: r.instagram ?? null,
      facebook: r.facebook ?? null,
      twitter: r.twitter ?? null,
      telegram: r.telegram ?? null,
      website: (r as any).website ?? (r as any).site ?? null,
      notes: (r as any).notes ?? (r as any).observacao ?? null,
      updated_at: r.updated_at ?? null,
      city: (r as any).city ?? (r as any).installation_city ?? null,
      state: (r as any).state ?? null,
    }));
    return res.json({ items, total: count ?? 0 });
  } catch (e: any) {
    return res
      .status(500)
      .json({ error: e?.message || "crm contacts list error" });
  }
});

// Get one lead contact
app.get("/livechat/crm/contacts/:id", requireAuth, async (req, res) => {
  const { id } = req.params as { id: string };
  const { data, error } = await supabaseAdmin
    .from("leads")
    .select(
      "id, name, phone, email, instagram, facebook, twitter, telegram, website, site, notes, observacoes",
    )
    .eq("id", id)
    .maybeSingle();
  if (error) return res.status(500).json({ error: error.message });
  if (!data) return res.status(404).json({ error: "Contato n?o encontrado" });
  return res.json({
    id: (data as any).id,
    name: (data as any).name || (data as any).id,
    phone: (data as any).phone || null,
    email: (data as any).email || null,
    instagram: (data as any).instagram || null,
    facebook: (data as any).facebook || null,
    twitter: (data as any).twitter || null,
    telegram: (data as any).telegram || null,
    website: (data as any).website || (data as any).site || null,
    notes: (data as any).notes || (data as any).observacoes || null,
  });
});

// Create lead contact
app.post("/livechat/crm/contacts", requireAuth, async (req: any, res) => {
  try {
    const authUserId = req.user.id as string;
    const { data: urow, error: errU } = await supabaseAdmin
      .from("users")
      .select("company_id")
      .eq("user_id", authUserId)
      .maybeSingle();
    if (errU) return res.status(500).json({ error: errU.message });
    if (!urow?.company_id)
      return res.status(404).json({ error: "Usu?rio sem company_id" });
    const b = req.body || {};
    const payload: any = {
      company_id: (urow as any).company_id,
      name: b.name ?? null,
      phone: b.phone ?? null,
      email: b.email ?? null,
      instagram: b.instagram ?? null,
      facebook: b.facebook ?? null,
      twitter: b.twitter ?? null,
      telegram: b.telegram ?? null,
      website: b.website ?? null,
      notes: b.notes ?? null,
    };
    const { data, error } = await supabaseAdmin
      .from("leads")
      .insert([payload])
      .select("id, name, phone, email, updated_at")
      .single();
    if (error) return res.status(500).json({ error: error.message });
    try {
      io.emit("crm:contact:created", {
        id: (data as any).id,
        name: (data as any).name,
        phone: (data as any).phone,
        email: (data as any).email,
        updated_at: (data as any).updated_at,
      });
    } catch {}
    return res.status(201).json({ id: (data as any).id });
  } catch (e: any) {
    return res
      .status(500)
      .json({ error: e?.message || "crm contact create error" });
  }
});

// Update lead contact
app.put("/livechat/crm/contacts/:id", requireAuth, async (req, res) => {
  const { id } = req.params as { id: string };
  const b = req.body || {};
  const payload: any = {};
  for (const k of [
    "name",
    "phone",
    "email",
    "instagram",
    "facebook",
    "twitter",
    "telegram",
    "website",
    "notes",
  ]) {
    if (b[k] !== undefined) payload[k] = b[k];
  }
  const { data, error } = await supabaseAdmin
    .from("leads")
    .update(payload)
    .eq("id", id)
    .select("id, name, phone, email, updated_at")
    .maybeSingle();
  if (error) return res.status(500).json({ error: error.message });
  try {
    io.emit("crm:contact:updated", {
      id: (data as any)?.id ?? id,
      name: (data as any)?.name,
      phone: (data as any)?.phone,
      email: (data as any)?.email,
      updated_at: (data as any)?.updated_at,
    });
  } catch {}
  return res.json({ id: (data as any)?.id ?? id });
});

// Start or open chat from a lead contact: ensure customers/customers row, then upsert chat
app.post(
  "/livechat/crm/contacts/:id/start-chat",
  requireAuth,
  async (req: any, res) => {
    const { id } = req.params as { id: string };
    const { inboxId } = (req.body || {}) as { inboxId?: string };
    if (!inboxId) return res.status(400).json({ error: "inboxId obrigatorio" });
    try {
      // Check acting user is linked to inbox
      let actingUserLocalId: string | null = null;
      try {
        const { data: urow } = await supabaseAdmin
          .from("users")
          .select("id")
          .eq("user_id", req.user.id)
          .maybeSingle();
        actingUserLocalId = (urow as any)?.id || null;
      } catch {}
      if (actingUserLocalId) {
        const { data: link } = await supabaseAdmin
          .from("inbox_users")
          .select("id")
          .eq("inbox_id", inboxId)
          .eq("user_id", actingUserLocalId)
          .maybeSingle();
        if (!link)
          return res.status(403).json({ error: "Sem permiss?o na inbox" });
      }

      // Load lead
      const normalizePhoneDigits = (value: any) => {
        if (value === undefined || value === null) return "";
        if (typeof value === "number") return String(value).replace(/\\D/g, "");
        if (typeof value === "string") return value.replace(/\\D/g, "");
        return "";
      };

      const { data: lead } = await supabaseAdmin
        .from("leads")
        .select("id, name, phone, email, company_id")
        .eq("id", id)
        .maybeSingle();
      if (!lead) return res.status(404).json({ error: "Lead n?o encontrado" });

      const phoneDigits = normalizePhoneDigits((lead as any).phone);

      if (!phoneDigits)
        return res.status(400).json({ error: "Lead sem telefone cadastrado" });

      const leadCompanyId = (lead as any).company_id || null;

      if (!leadCompanyId)
        return res.status(400).json({ error: "Lead sem empresa vinculada" });

      const ensureCustomerSync = async (customer: any | null) => {
        if (!customer?.id) return null;

        const updates: Record<string, any> = {};

        if (!customer.phone || customer.phone !== phoneDigits)
          updates.phone = phoneDigits;

        if (!customer.lead_id) updates.lead_id = id;

        if (!customer.company_id) updates.company_id = leadCompanyId;

        if (Object.keys(updates).length > 0) {
          const { data: updated, error: updateError } = await supabaseAdmin

            .from("customers")

            .update(updates)

            .eq("id", customer.id)

            .select("id, phone, lead_id, company_id")

            .maybeSingle();

          if (updateError) {
            if ((updateError as any)?.code === "23505") {
              const { data: existingByPhone } = await supabaseAdmin

                .from("customers")

                .select("id, phone, lead_id, company_id")

                .eq("phone", phoneDigits)

                .maybeSingle();

              if (existingByPhone?.id) return existingByPhone;
            }

            throw updateError;
          }

          if (updated) return updated;
        }

        return customer;
      };

      const findCustomerByPhone = async () => {
        const { data: existingByPhone } = await supabaseAdmin

          .from("customers")

          .select("id, phone, lead_id, company_id")

          .eq("phone", phoneDigits)

          .maybeSingle();

        return existingByPhone
          ? await ensureCustomerSync(existingByPhone)
          : null;
      };

      let customerRecord: any = null;

      try {
        const { data: cust } = await supabaseAdmin

          .from("customers")

          .select("id, phone, lead_id, company_id")

          .eq("id", id)

          .maybeSingle();

        if (cust?.id) customerRecord = await ensureCustomerSync(cust);
      } catch {}

      if (!customerRecord) {
        try {
          const { data: cos } = await supabaseAdmin

            .from("customers")

            .select("id, phone, lead_id, company_id")

            .eq("lead_id", id)

            .maybeSingle();

          if (cos?.id) customerRecord = await ensureCustomerSync(cos);
        } catch {}
      }

      if (!customerRecord) {
        try {
          customerRecord = await findCustomerByPhone();
        } catch {}
      }

      if (!customerRecord) {
        try {
          const payload: any = {
            id,

            company_id: leadCompanyId,

            lead_id: id,

            name: (lead as any).name || id,

            phone: phoneDigits,

            email: (lead as any).email || null,
          };

          const { data: created, error: createError } = await supabaseAdmin

            .from("customers")

            .insert([payload])

            .select("id, phone, lead_id, company_id")

            .single();

          if (createError) {
            if ((createError as any)?.code === "23505") {
              customerRecord = await findCustomerByPhone();
            } else {
              return res
                .status(500)
                .json({
                  error:
                    createError.message ||
                    "Falha ao criar customer para o lead",
                });
            }
          } else {
            customerRecord = created;
          }
        } catch (e) {
          return res
            .status(500)
            .json({ error: "Falha ao criar customer para o lead" });
        }
      }

      if (!customerRecord || !customerRecord.id) {
        return res
          .status(500)
          .json({ error: "Falha ao determinar customer do lead" });
      }

      const customerId = (customerRecord as any).id as string;

      // Upsert chat
      const { data: chat, error: errUpsert } = await supabaseAdmin
        .from("chats")
        .upsert(
          { inbox_id: inboxId, customer_id: customerId, status: "OPEN" },
          { onConflict: "inbox_id,customer_id" },
        )
        .select("id")
        .single();
      if (errUpsert) return res.status(500).json({ error: errUpsert.message });
      return res.json({ id: (chat as any).id });
    } catch (e: any) {
      return res.status(500).json({ error: e?.message || "start chat error" });
    }
  },
);

// Participantes (adicionar/remover)
app.post("/livechat/chats/:id/participants", requireAuth, async (req, res) => {
  const { id } = req.params as { id: string };
  const { userId } = req.body || {};
  if (!userId) return res.status(400).json({ error: "userId obrigatorio" });
  // upsert pelo unique (chat_id, user_id): ativa novamente se j? existir
  const nowIso = new Date().toISOString();
  const { data, error } = await supabaseAdmin
    .from("chat_participants")
    .upsert(
      [
        {
          chat_id: id,
          user_id: userId,
          is_active: true,
          left_at: null,
          joined_at: nowIso,
        },
      ],
      { onConflict: "chat_id,user_id" },
    )
    .select("*")
    .single();
  if (error) return res.status(500).json({ error: error.message });
  return res.status(201).json(data);
});

app.delete(
  "/livechat/chats/:id/participants/:userId",
  requireAuth,
  async (req, res) => {
    const { id, userId } = req.params as { id: string; userId: string };
    const { error } = await supabaseAdmin
      .from("chat_participants")
      .update({ is_active: false, left_at: new Date().toISOString() })
      .eq("chat_id", id)
      .eq("user_id", userId);
    if (error) return res.status(500).json({ error: error.message });
    return res.status(204).send();
  },
);

// Listar participantes do chat com nome e papel
app.get(
  "/livechat/chats/:id/participants",
  requireAuth,
  async (req: any, res) => {
    const { id } = req.params as { id: string };
    try {
      const { data: rows, error } = await supabaseAdmin
        .from("chat_participants")
        .select("user_id, joined_at, left_at, is_active")
        .eq("chat_id", id);
      if (error) return res.status(500).json({ error: error.message });
      const uids = Array.from(
        new Set((rows || []).map((r: any) => r.user_id).filter(Boolean)),
      );
      let usersMap: Record<
        string,
        { name: string | null; role: string | null; user_id: string | null }
      > = {};
      if (uids.length > 0) {
        const { data: users } = await supabaseAdmin
          .from("users")
          .select("id, user_id, name, role")
          .in("id", uids);
        for (const u of users || []) {
          usersMap[(u as any).id] = {
            name: (u as any).name || (u as any).id,
            role: (u as any).role || null,
            user_id: (u as any).user_id || null,
          };
        }
      }
      const list = (rows || []).map((r: any) => ({
        id: r.user_id,
        name: usersMap[r.user_id]?.name || r.user_id,
        role: usersMap[r.user_id]?.role || null,
        is_current: usersMap[r.user_id]?.user_id === req.user.id,
      }));
      return res.json(list);
    } catch (e: any) {
      return res
        .status(500)
        .json({ error: e?.message || "participants error" });
    }
  },
);

// Usu?rios (agentes/supervisores) vinculados a uma inbox espec?fica
app.get(
  "/livechat/inboxes/:inboxId/agents",
  requireAuth,
  async (req: any, res) => {
    const { inboxId } = req.params as { inboxId: string };
    try {
      const { data: links, error: errLinks } = await supabaseAdmin
        .from("inbox_users")
        .select("id, user_id")
        .eq("inbox_id", inboxId);
      if (errLinks) return res.status(500).json({ error: errLinks.message });
      const raw = (links || []) as any[];
      const rawIds = Array.from(
        new Set(raw.map((r: any) => r.user_id).filter(Boolean)),
      );
      if (rawIds.length === 0) return res.json([]);

      // Tenta interpretar como users.id
      let users: any[] = [];
      const { data: byLocal } = await supabaseAdmin
        .from("users")
        .select("id, user_id, name, role")
        .in("id", rawIds)
        .order("name", { ascending: true });
      users = byLocal || [];
      if (!users || users.length === 0) {
        // Fallback: interpretar como auth user_id
        const { data: byAuth } = await supabaseAdmin
          .from("users")
          .select("id, user_id, name, role")
          .in("user_id", rawIds)
          .order("name", { ascending: true });
        users = byAuth || [];
      }
      const byUser: Record<string, any> = Object.fromEntries(
        (users || []).map((u: any) => [u.id, u]),
      );
      const result = raw
        .map((link: any) => {
          const u = byUser[link.user_id];
          if (!u) return null;
          return {
            id: link.id,
            user_id: u.id,
            name: u.name || u.id,
            role: u.role,
          };
        })
        .filter(Boolean);
      return res.json(result);
    } catch (e: any) {
      return res
        .status(500)
        .json({ error: e?.message || "inbox agents error" });
    }
  },
);

// Definir respons?vel (assignee) do contato do chat, validando com inbox_users
app.put("/livechat/chats/:id/assignee", requireAuth, async (req: any, res) => {
  const { id } = req.params as { id: string };
  // Aceita UUID ou qualquer string n?o vazia como id local (flex?vel a diferentes esquemas)
  const schema = z.object({ userId: z.string().min(1).nullable() });
  const parsed = schema.safeParse(req.body || {});
  if (!parsed.success)
    return res.status(400).json({ error: parsed.error.message });
  const newAssigneeId = parsed.data.userId; // users.id (public)

  try {
    // Carregar chat (inbox e customer)
    const { data: chat, error: errChat } = await supabaseAdmin
      .from("chats")
      .select("id, inbox_id, customer_id")
      .eq("id", id)
      .maybeSingle();
    if (errChat) return res.status(500).json({ error: errChat.message });
    if (!chat) return res.status(404).json({ error: "Chat n?o encontrado" });

    // Resolver id local do usu?rio autenticado
    let actingUserLocalId: string | null = null;
    try {
      const { data: urow } = await supabaseAdmin
        .from("users")
        .select("id")
        .eq("user_id", req.user.id)
        .maybeSingle();
      actingUserLocalId = (urow as any)?.id || null;
    } catch {}

    // Validar permiss?o do usu?rio que est? efetuando a troca (precisa pertencer ? inbox e poder escrever)
    if (actingUserLocalId) {
      const { data: linkAct } = await supabaseAdmin
        .from("inbox_users")
        .select("can_write, can_manage")
        .eq("inbox_id", (chat as any).inbox_id)
        .eq("user_id", actingUserLocalId)
        .maybeSingle();
      if (!linkAct || (!linkAct.can_write && !linkAct.can_manage)) {
        return res
          .status(403)
          .json({ error: "Sem permiss?o para atribuir nesta inbox" });
      }
    }

    // Se definir um novo respons?vel, ele precisa estar vinculado a esta inbox
    if (newAssigneeId) {
      const { data: link } = await supabaseAdmin
        .from("inbox_users")
        .select("id")
        .eq("inbox_id", (chat as any).inbox_id)
        .eq("user_id", newAssigneeId)
        .maybeSingle();
      if (!link)
        return res
          .status(400)
          .json({ error: "Usu?rio n?o est? autorizado nesta inbox" });
    }

    // Atualizar atribui??o no contato (customers/customers/leads)
    const custId = (chat as any).customer_id as string;
    let linkedLeadId: string | null = null;

    // Tenta atualizar customers por id
    try {
      const { data: cRow, error: errC } = await supabaseAdmin
        .from("customers")
        .update({ assigned_agent: newAssigneeId || null })
        .eq("id", custId)
        .select("id")
        .maybeSingle();
      if (errC) throw errC;
      if (cRow) {
        // se houver leads que apontam para este customer, sincroniza
        try {
          const { data: leadsRows } = await supabaseAdmin
            .from("leads")
            .select("id")
            .eq("customer_id", custId);
          for (const r of leadsRows || []) {
            const leadId = (r as any).id as string;
            await supabaseAdmin
              .from("leads")
              .update({ assigned_to_id: newAssigneeId || null })
              .eq("id", leadId);
            linkedLeadId = leadId;
          }
        } catch {}
      }
    } catch {}

    // Tenta atualizar customers por id (e capturar lead_id)
    if (!linkedLeadId) {
      try {
        const { data: cosRow } = await supabaseAdmin
          .from("customers")
          .update({ assigned_agent: newAssigneeId || null })
          .eq("id", custId)
          .select("id, lead_id")
          .maybeSingle();
        if (cosRow?.lead_id) linkedLeadId = (cosRow as any).lead_id as string;
      } catch {}
    }

    // Se o customer_id for diretamente um lead, atualiza o lead
    try {
      const { data: leadRow } = await supabaseAdmin
        .from("leads")
        .select("id")
        .eq("id", custId)
        .maybeSingle();
      if (leadRow?.id) linkedLeadId = (leadRow as any).id as string;
    } catch {}

    // Sincronizar lead e cards vinculados
    if (linkedLeadId) {
      try {
        await supabaseAdmin
          .from("leads")
          .update({ assigned_to_id: newAssigneeId || null })
          .eq("id", linkedLeadId);
      } catch {}
      // Tamb?m refletir no customers vinculado por lead_id (quando existir)
      try {
        await supabaseAdmin
          .from("customers")
          .update({ assigned_agent: newAssigneeId || null })
          .eq("lead_id", linkedLeadId);
      } catch {}
      try {
        // Atualizar cards deste lead e emitir sockets para o funil
        const { data: updatedCards } = await supabaseAdmin
          .from("kanban_cards")
          .update({ owner_user_id: newAssigneeId || null })
          .eq("lead_id", linkedLeadId)
          .select(
            "id, title, value_numeric, kanban_column_id, owner_user_id, source, notes, email, contact, lead_id",
          );
        for (const r of updatedCards || []) {
          const payload = {
            id: (r as any).id,
            title: (r as any).title,
            value: Number((r as any).value_numeric || 0),
            stage: (r as any).kanban_column_id,
            owner: (r as any).owner_user_id || null,
            source: (r as any).source || null,
            notes: (r as any).notes || null,
            email: (r as any).email || null,
            contact: (r as any).contact || null,
            leadId: (r as any).lead_id || null,
          };
          try {
            io.emit("kanban:card:updated", payload);
          } catch {}
        }
      } catch {}
    }

    // Nome do usu?rio atribu?do (para o livechat)
    let assignedName: string | null = null;
    if (newAssigneeId) {
      const { data: u } = await supabaseAdmin
        .from("users")
        .select("id, name")
        .eq("id", newAssigneeId)
        .maybeSingle();
      assignedName = (u as any)?.name || null;
    }

    // Garantir atualiza??o no chat.assignee_agent com id de inbox_users
    let targetLinkId: string | null = null;
    try {
      if (newAssigneeId) {
        const { data: l } = await supabaseAdmin
          .from("inbox_users")
          .select("id")
          .eq("inbox_id", (chat as any).inbox_id)
          .eq("user_id", newAssigneeId)
          .maybeSingle();
        targetLinkId = (l as any)?.id || null;
      }
      await supabaseAdmin
        .from("chats")
        .update({ assignee_agent: targetLinkId })
        .eq("id", id);
    } catch {}

    let resolvedLinkId: string | null = targetLinkId;
    if (resolvedLinkId === null) {
      try {
        const { data: chatNow } = await supabaseAdmin
          .from("chats")
          .select("assignee_agent")
          .eq("id", id)
          .maybeSingle();
        resolvedLinkId = (chatNow as any)?.assignee_agent || null;
      } catch {}
    }

    // Notificar UI do livechat
    io.emit("chat:updated", {
      chatId: id,
      assigned_agent_id: resolvedLinkId,
      assigned_agent_name: assignedName,
      assigned_agent_user_id: newAssigneeId || null,
    });
    return res.json({
      ok: true,
      assigned_agent_id: resolvedLinkId,
      assigned_agent_name: assignedName,
      assigned_agent_user_id: newAssigneeId || null,
    });
  } catch (e: any) {
    return res
      .status(500)
      .json({ error: e?.message || "Falha ao definir respons?vel" });
  }
});
// ===== Start =====
server.listen(PORT, () => {
  console.log(`Backend rodando em http://localhost:${PORT}`);
});

// (removido supabase gen?rico; usar supabaseAdmin em todas as rotas protegidas)

// Variante A: sua tabela "users" usa a MESMA PK id = auth.users.id
app.get("/kanban/my-board", requireAuth, async (req: any, res) => {
  const userId = req.user.id;

  // Busca a empresa do Usu rio autenticado na tabela public.users
  const { data: userRow, error: errUser } = await supabaseAdmin
    .from("users")
    .select("company_id")
    .eq("user_id", userId)
    .maybeSingle();

  if (errUser) return res.status(500).json({ error: errUser.message });
  if (!userRow?.company_id)
    return res.status(404).json({ error: "Usu rio sem company_id" });

  const { data: board, error: errBoard } = await supabaseAdmin
    .from("kanban_boards")
    .select("id, name, is_default")
    .eq("company_id", userRow.company_id)
    .order("is_default", { ascending: false })
    .order("created_at", { ascending: true })
    .limit(1)
    .maybeSingle();

  if (errBoard) return res.status(500).json({ error: errBoard.message });
  if (!board)
    return res.status(404).json({ error: "Nenhum board para a empresa" });

  res.json(board); // { id, name, is_default }
});

// GET colunas do board
app.get("/kanban/boards/:boardId/columns", requireAuth, async (req, res) => {
  const { boardId } = req.params;

  const { data, error } = await supabaseAdmin
    .from("kanban_columns")
    .select("id, name, color, position")
    .eq("kanban_board_id", boardId)
    .order("position", { ascending: true });

  if (error) return res.status(500).json({ error: error.message });

  const mapped = (data || []).map((c) => ({
    id: c.id,
    title: c.name,
    color: c.color || "#6B7280",
    position: c.position,
  }));
  res.json(mapped);
});

// PUT reorder columns positions
app.put(
  "/kanban/boards/:boardId/columns/reorder",
  requireAuth,
  async (req, res) => {
    const { boardId } = req.params as { boardId: string };
    const { columnIds } = (req.body || {}) as { columnIds?: string[] };

    if (!Array.isArray(columnIds) || columnIds.length === 0) {
      return res.status(400).json({ error: "Lista de colunas invlida" });
    }

    const { data: existingCols, error: fetchError } = await supabaseAdmin
      .from("kanban_columns")
      .select("id, position")
      .eq("kanban_board_id", boardId);

    if (fetchError) return res.status(500).json({ error: fetchError.message });

    const currentList = existingCols || [];
    const currentSet = new Set(currentList.map((col: any) => col.id));
    const inputSet = new Set(columnIds);

    if (inputSet.size !== columnIds.length) {
      return res
        .status(400)
        .json({ error: "Lista de colunas contm duplicados" });
    }

    if (currentList.length !== columnIds.length) {
      return res
        .status(400)
        .json({ error: "Lista de colunas no corresponde ao board" });
    }

    for (const id of columnIds) {
      if (!currentSet.has(id)) {
        return res
          .status(400)
          .json({ error: "Coluna invlida para este board" });
      }
    }

    const maxPosition = currentList.reduce((max: number, col: any) => {
      const pos =
        typeof col.position === "number"
          ? col.position
          : Number(col.position) || 0;
      return pos > max ? pos : max;
    }, 0);
    const tempOffset = maxPosition + columnIds.length + 5;

    for (let i = 0; i < columnIds.length; i++) {
      const id = columnIds[i];
      const { error } = await supabaseAdmin
        .from("kanban_columns")
        .update({ position: tempOffset + i })
        .eq("id", id);
      if (error) return res.status(500).json({ error: error.message });
    }

    for (let i = 0; i < columnIds.length; i++) {
      const id = columnIds[i];
      const { error } = await supabaseAdmin
        .from("kanban_columns")
        .update({ position: i + 1 })
        .eq("id", id);
      if (error) return res.status(500).json({ error: error.message });
    }

    const { data: refreshed, error: refreshError } = await supabaseAdmin
      .from("kanban_columns")
      .select("id, name, color, position")
      .eq("kanban_board_id", boardId)
      .order("position", { ascending: true });

    if (refreshError)
      return res.status(500).json({ error: refreshError.message });

    return res.json(
      (refreshed || []).map((c: any) => ({
        id: c.id,
        title: c.name,
        color: c.color || "#6B7280",
        position: c.position,
      })),
    );
  },
);
// PUT atualizar coluna (nome, cor, posi??o)
app.put("/kanban/columns/:id", requireAuth, async (req, res) => {
  const { id } = req.params as { id: string };
  const { name, color, position } = (req.body || {}) as {
    name?: string;
    color?: string;
    position?: number;
  };

  const update: any = {};
  if (name !== undefined) update.name = name;
  if (color !== undefined) update.color = color;
  if (position !== undefined) update.position = position;

  if (Object.keys(update).length === 0) {
    return res.status(400).json({ error: "Nenhum campo para atualizar" });
  }

  const { data, error } = await supabaseAdmin
    .from("kanban_columns")
    .update(update)
    .eq("id", id)
    .select("id, name, color, position")
    .single();

  if (error) return res.status(500).json({ error: error.message });

  return res.json({
    id: data.id,
    title: data.name,
    color: data.color || "#6B7280",
    position: data.position,
  });
});

// GET cards do board
app.get("/kanban/boards/:boardId/cards", requireAuth, async (req, res) => {
  const { boardId } = req.params;

  const { data, error } = await supabaseAdmin
    .from("kanban_cards")
    .select(
      `
      id, title, description, value_numeric, currency,
      owner_user_id, source, notes, kanban_column_id,
      email, contact, position, lead_id
    `,
    )
    .eq("kanban_board_id", boardId)
    .order("kanban_column_id", { ascending: true })
    .order("position", { ascending: true });

  if (error) return res.status(500).json({ error: error.message });

  const mapped = (data || []).map((r) => ({
    id: r.id,
    title: r.title,
    value: Number(r.value_numeric || 0),
    stage: r.kanban_column_id,
    owner: r.owner_user_id || null,
    description: (r as any).description || null,
    source: r.source || null,
    notes: r.notes || null,
    email: r.email || null,
    contact: r.contact || null,
    leadId: (r as any).lead_id || null,
    position: r.position,
  }));
  res.json(mapped);
});

// POST criar card
app.post("/kanban/cards", async (req, res) => {
  const {
    boardId,
    columnId,
    title,
    value = 0,
    source = null,
    owner = null,
    email = null,
    contact = null,
    leadId = null,
  } = req.body;

  if (!boardId || !columnId || !title) {
    return res
      .status(400)
      .json({ error: "boardId, columnId e title s o obrigat rios" });
  }

  // calcula pr?xima posi??o da coluna
  const { data: last, error: errLast } = await supabaseAdmin
    .from("kanban_cards")
    .select("position")
    .eq("kanban_column_id", columnId)
    .order("position", { ascending: false })
    .limit(1)
    .maybeSingle();

  if (errLast) return res.status(500).json({ error: errLast.message });

  const nextPos = (last?.position || 0) + 1;

  // Valida??o b?sica do owner (se informado) existir na tabela users
  if (owner) {
    const { data: uexists } = await supabaseAdmin
      .from("users")
      .select("id")
      .eq("id", owner)
      .maybeSingle();
    if (!uexists)
      return res.status(400).json({ error: "Usu?rio (owner) inv?lido" });
  }

  const { data, error } = await supabaseAdmin
    .from("kanban_cards")
    .insert([
      {
        kanban_board_id: boardId,
        kanban_column_id: columnId,
        title,
        value_numeric: value,
        source,
        owner_user_id: owner,
        email,
        contact,
        position: nextPos,
        ...(leadId ? { lead_id: leadId } : {}),
      },
    ])
    .select("*")
    .single();

  if (error) return res.status(500).json({ error: error.message });

  // If linked to a lead, sync lead's kanban fields
  try {
    const linkedLeadId = (data as any).lead_id as string | null;
    if (linkedLeadId) {
      await supabaseAdmin
        .from("leads")
        .update({
          kanban_board_id: (data as any).kanban_board_id,
          kanban_column_id: (data as any).kanban_column_id,
          assigned_to_id: (data as any).owner_user_id || null,
        })
        .eq("id", linkedLeadId);
      // Best-effort: if there is a customers/customers row with same id, sync assigned_agent as well
      try {
        // Try customers first
        await supabaseAdmin
          .from("customers")
          .update({ assigned_agent: (data as any).owner_user_id || null })
          .eq("id", linkedLeadId);
        // Also try legacy table name customers (ignore errors if it doesn't exist)
        try {
          await supabaseAdmin
            .from("customers")
            .update({ assigned_agent: (data as any).owner_user_id || null })
            .eq("lead_id", linkedLeadId);
        } catch {}
        // Emit update for any chats tied to this customer/lead
        try {
          const assignedId = (data as any).owner_user_id || null;
          let assignedName: string | null = null;
          if (assignedId) {
            const { data: u } = await supabaseAdmin
              .from("users")
              .select("id, name")
              .eq("id", assignedId)
              .maybeSingle();
            assignedName = (u as any)?.name || null;
          }
          // Find customers linked to this lead
          let costumerIds: string[] = [];
          try {
            const { data: cRows } = await supabaseAdmin
              .from("customers")
              .select("id")
              .eq("lead_id", linkedLeadId);
            costumerIds = (cRows || []).map((r: any) => r.id).filter(Boolean);
          } catch {}
          // Collect chats and inboxes for authorization check
          const chatIds: string[] = [];
          const inboxIds: string[] = [];
          try {
            // Legacy: customer_id == lead id
            const { data: chatsLegacy } = await supabaseAdmin
              .from("chats")
              .select("id,inbox_id")
              .eq("customer_id", linkedLeadId);
            for (const row of chatsLegacy || []) {
              chatIds.push((row as any).id);
              if ((row as any).inbox_id) inboxIds.push((row as any).inbox_id);
            }
          } catch {}
          try {
            if (costumerIds.length > 0) {
              const { data: chatsByCostumer } = await supabaseAdmin
                .from("chats")
                .select("id,inbox_id")
                .in("customer_id", costumerIds);
              for (const row of chatsByCostumer || []) {
                chatIds.push((row as any).id);
                if ((row as any).inbox_id) inboxIds.push((row as any).inbox_id);
              }
            }
          } catch {}
          const uniqChatIds = Array.from(new Set(chatIds));
          const uniqInboxIds = Array.from(new Set(inboxIds));

          // Determine if assigned user is allowed in at least one inbox for this customer
          let allowed = false;
          if (assignedId && uniqInboxIds.length > 0) {
            try {
              const { data: links } = await supabaseAdmin
                .from("inbox_users")
                .select("id")
                .eq("user_id", assignedId)
                .in("inbox_id", uniqInboxIds);
              allowed = !!(links && (links as any[]).length > 0);
            } catch {}
          }

          const effectiveAssignedId = assignedId && allowed ? assignedId : null;
          const effectiveAssignedName =
            assignedId && allowed ? assignedName : null;

          // Ensure contact tables reflect the effective assignment
          try {
            await supabaseAdmin
              .from("customers")
              .update({ assigned_agent: effectiveAssignedId })
              .eq("id", linkedLeadId);
          } catch {}
          try {
            await supabaseAdmin
              .from("customers")
              .update({ assigned_agent: effectiveAssignedId })
              .eq("lead_id", linkedLeadId);
          } catch {}

          for (const cid of uniqChatIds) {
            io.emit("chat:updated", {
              chatId: cid,
              assigned_agent_id: effectiveAssignedId,
              assigned_agent_name: effectiveAssignedName,
            });
          }
        } catch {}
      } catch {}
    }
  } catch (e) {
    // log only; do not fail card creation if lead update fails
    console.error("Failed to sync lead after card create:", e);
  }

  const mapped = {
    id: data.id,
    title: data.title,
    value: Number(data.value_numeric || 0),
    stage: data.kanban_column_id,
    owner: data.owner_user_id || null,
    source: data.source || null,
    notes: data.notes || null,
    email: data.email || null,
    contact: data.contact || null,
    leadId: (data as any).lead_id || null,
  };
  // Notify listeners (e.g., funnel UIs) about the new/updated card
  try {
    io.emit("kanban:card:updated", mapped);
  } catch {}
  res.status(201).json(mapped);
});

// PUT atualizar card (titulo, valor, stage, etc.)
app.put("/kanban/cards/:id", async (req, res) => {
  const { id } = req.params;
  const patch = req.body as Partial<{
    title: string;
    value: number;
    stage: string;
    owner: string;
    source: string;
    notes: string;
    email: string;
    contact: string;
    leadId: string | null;
    description: string | null;
    position: number;
  }>;

  const updatePayload: any = {};
  if (patch.title !== undefined) updatePayload.title = patch.title;
  if (patch.value !== undefined) updatePayload.value_numeric = patch.value;
  if (patch.stage !== undefined) updatePayload.kanban_column_id = patch.stage;
  if (patch.owner !== undefined) {
    if (patch.owner) {
      const { data: uexists } = await supabaseAdmin
        .from("users")
        .select("id")
        .eq("id", patch.owner)
        .maybeSingle();
      if (!uexists)
        return res.status(400).json({ error: "Usu?rio (owner) inv?lido" });
    }
    updatePayload.owner_user_id = patch.owner;
  }
  if (patch.source !== undefined) updatePayload.source = patch.source;
  if (patch.notes !== undefined) updatePayload.notes = patch.notes;
  if (patch.email !== undefined) updatePayload.email = patch.email;
  if (patch.contact !== undefined) updatePayload.contact = patch.contact;
  if (patch.leadId !== undefined) updatePayload.lead_id = patch.leadId;
  if (patch.description !== undefined)
    updatePayload.description = patch.description;
  if (patch.position !== undefined) updatePayload.position = patch.position;

  const { data, error } = await supabaseAdmin
    .from("kanban_cards")
    .update(updatePayload)
    .eq("id", id)
    .select("*")
    .single();

  if (error) return res.status(500).json({ error: error.message });

  // If linked to a lead, sync lead's kanban fields according to updated card
  try {
    const linkedLeadId = (data as any).lead_id as string | null;
    if (linkedLeadId) {
      await supabaseAdmin
        .from("leads")
        .update({
          kanban_board_id: (data as any).kanban_board_id,
          kanban_column_id: (data as any).kanban_column_id,
          assigned_to_id: (data as any).owner_user_id || null,
        })
        .eq("id", linkedLeadId);
      // Best-effort: sync customers/customers.assigned_agent if customer is linked to this lead
      try {
        // Emit update for any chats tied to this customer/lead and set contact assignment if allowed in inbox
        try {
          const assignedId = (data as any).owner_user_id || null;
          let assignedName: string | null = null;
          if (assignedId) {
            const { data: u } = await supabaseAdmin
              .from("users")
              .select("id, name")
              .eq("id", assignedId)
              .maybeSingle();
            assignedName = (u as any)?.name || null;
          }
          // Find customers linked to this lead
          let costumerIds: string[] = [];
          try {
            const { data: cRows } = await supabaseAdmin
              .from("customers")
              .select("id")
              .eq("lead_id", linkedLeadId);
            costumerIds = (cRows || []).map((r: any) => r.id).filter(Boolean);
          } catch {}
          // Collect chats and inboxes
          const chatIds: string[] = [];
          const inboxIds: string[] = [];
          try {
            const { data: chatsLegacy } = await supabaseAdmin
              .from("chats")
              .select("id,inbox_id")
              .eq("customer_id", linkedLeadId);
            for (const row of chatsLegacy || []) {
              chatIds.push((row as any).id);
              if ((row as any).inbox_id) inboxIds.push((row as any).inbox_id);
            }
          } catch {}
          try {
            if (costumerIds.length > 0) {
              const { data: chatsByCostumer } = await supabaseAdmin
                .from("chats")
                .select("id,inbox_id")
                .in("customer_id", costumerIds);
              for (const row of chatsByCostumer || []) {
                chatIds.push((row as any).id);
                if ((row as any).inbox_id) inboxIds.push((row as any).inbox_id);
              }
            }
          } catch {}
          const uniqChatIds = Array.from(new Set(chatIds));
          const uniqInboxIds = Array.from(new Set(inboxIds));

          // Check authorization of assigned user for inboxes
          let allowed = false;
          if (assignedId && uniqInboxIds.length > 0) {
            try {
              const { data: links } = await supabaseAdmin
                .from("inbox_users")
                .select("id")
                .eq("user_id", assignedId)
                .in("inbox_id", uniqInboxIds);
              allowed = !!(links && (links as any[]).length > 0);
            } catch {}
          }

          const effectiveAssignedId = assignedId && allowed ? assignedId : null;
          const effectiveAssignedName =
            assignedId && allowed ? assignedName : null;

          // Ensure contact tables reflect the effective assignment
          try {
            await supabaseAdmin
              .from("customers")
              .update({ assigned_agent: effectiveAssignedId })
              .eq("id", linkedLeadId);
          } catch {}
          try {
            await supabaseAdmin
              .from("customers")
              .update({ assigned_agent: effectiveAssignedId })
              .eq("lead_id", linkedLeadId);
          } catch {}

          for (const cid of uniqChatIds) {
            io.emit("chat:updated", {
              chatId: cid,
              assigned_agent_id: effectiveAssignedId,
              assigned_agent_name: effectiveAssignedName,
            });
          }
        } catch {}
      } catch {}
    }
  } catch (e) {
    console.error("Failed to sync lead after card update:", e);
  }

  const mapped = {
    id: data.id,
    title: data.title,
    value: Number((data as any).value_numeric || 0),
    stage: (data as any).kanban_column_id,
    owner: (data as any).owner_user_id || null,
    source: data.source || null,
    notes: data.notes || null,
    email: data.email || null,
    contact: data.contact || null,
    leadId: (data as any).lead_id || null,
  };
  // Notify listeners (e.g., funnel UIs) about the card update
  try {
    io.emit("kanban:card:updated", mapped);
  } catch {}
  res.json(mapped);
});

// Util: backfill sync from kanban_cards -> leads for current company
app.post("/kanban/sync-leads", requireAuth, async (req: any, res) => {
  try {
    const userId = req.user.id;
    const { data: userRow, error: errUser } = await supabaseAdmin
      .from("users")
      .select("company_id")
      .eq("user_id", userId)
      .maybeSingle();
    if (errUser) return res.status(500).json({ error: errUser.message });
    if (!userRow?.company_id)
      return res.status(404).json({ error: "Usu rio sem company_id" });

    // fetch cards for boards of this company
    const { data: boards, error: errBoards } = await supabaseAdmin
      .from("kanban_boards")
      .select("id")
      .eq("company_id", userRow.company_id);
    if (errBoards) return res.status(500).json({ error: errBoards.message });
    const boardIds = (boards || []).map((b: any) => b.id);
    if (boardIds.length === 0) return res.json({ updated: 0 });

    const { data: cards, error: errCards } = await supabaseAdmin
      .from("kanban_cards")
      .select("id, kanban_board_id, kanban_column_id, owner_user_id, lead_id")
      .in("kanban_board_id", boardIds);
    if (errCards) return res.status(500).json({ error: errCards.message });

    const toSync = (cards || []).filter((c: any) => !!c.lead_id);
    let updated = 0;
    for (const c of toSync) {
      const { error: errUp } = await supabaseAdmin
        .from("leads")
        .update({
          kanban_board_id: c.kanban_board_id,
          kanban_column_id: c.kanban_column_id,
          assigned_to_id: c.owner_user_id || null,
        })
        .eq("id", c.lead_id as string);
      if (!errUp) updated++;
    }

    return res.json({ updated });
  } catch (e: any) {
    return res.status(500).json({ error: e?.message || "Sync error" });
  }
});

// GET users with role AGENT or SUPERVISOR in same company
app.get("/users/agents-supervisors", requireAuth, async (req: any, res) => {
  const userId = req.user.id;

  const { data: userRow, error: errUser } = await supabaseAdmin
    .from("users")
    .select("company_id")
    .eq("user_id", userId)
    .maybeSingle();

  if (errUser) return res.status(500).json({ error: errUser.message });
  if (!userRow?.company_id)
    return res.status(404).json({ error: "Usu rio sem company_id" });

  const { data, error } = await supabaseAdmin
    .from("users")
    .select("id, user_id, name, role")
    .eq("company_id", userRow.company_id)
    .in("role", ["AGENT", "SUPERVISOR", "TECHNICIAN", "MANAGER", "ADMIN"])
    .order("name", { ascending: true });

  if (error) return res.status(500).json({ error: error.message });

  // Importante: retornar id = users.id (PK local) pois kanban_cards.owner_user_id referencia esta PK
  return res.json(
    (data || []).map((u) => ({
      id: (u as any).id,
      name: (u as any).name || (u as any).id,
      role: (u as any).role,
    })),
  );
});

// ===== Company Users (Agents/Supervisors) Management =====
// List users of current company (agents/supervisors only)
app.get("/settings/users", requireAuth, async (req: any, res) => {
  try {
    const { data: me, error: errMe } = await supabaseAdmin
      .from("users")
      .select("company_id, role")
      .eq("user_id", req.user.id)
      .maybeSingle();
    if (errMe) return res.status(500).json({ error: errMe.message });
    if (!me?.company_id)
      return res.status(404).json({ error: "Usu?rio sem company_id" });
    const { data, error } = await supabaseAdmin
      .from("users")
      .select(
        "id, email, name, avatar, role, status, is_online, last_seen, company_id, user_id",
      )
      .eq("company_id", me.company_id)
      .in("role", ["AGENT", "SUPERVISOR", "MANAGER"])
      .order("name", { ascending: true });
    if (error) return res.status(500).json({ error: error.message });
    return res.json(data || []);
  } catch (e: any) {
    return res.status(500).json({ error: e?.message || "users list error" });
  }
});

// Create a new agent/supervisor in current company (and auth user)
app.post("/settings/users", requireAuth, async (req: any, res) => {
  try {
    const { data: me, error: errMe } = await supabaseAdmin
      .from("users")
      .select("company_id, role")
      .eq("user_id", req.user.id)
      .maybeSingle();
    if (errMe) return res.status(500).json({ error: errMe.message });
    if (!me?.company_id)
      return res.status(404).json({ error: "Usu?rio sem company_id" });
    const schema = z.object({
      name: z.string().min(1),
      email: z.string().email(),
      role: z
        .enum(["AGENT", "SUPERVISOR", "TECHNICIAN", "MANAGER"])
        .default("AGENT"),
      password: z.string().min(6),
      avatarUrl: z.string().url().optional(),
    });
    const parsed = schema.safeParse(req.body || {});
    if (!parsed.success)
      return res
        .status(400)
        .json({ error: "Dados inv?lidos", details: parsed.error.format() });
    const b = parsed.data as any;

    // Create auth user
    const { data: authCreated, error: authErr } = await (
      supabaseAdmin as any
    ).auth.admin.createUser({
      email: b.email,
      password: b.password,
      email_confirm: true,
    });
    if (authErr) return res.status(400).json({ error: authErr.message });
    const authId = (authCreated?.user as any)?.id as string | null;

    const { data: inserted, error } = await supabaseAdmin
      .from("users")
      .insert([
        {
          name: b.name,
          email: b.email,
          role: b.role,
          avatar: b.avatarUrl ?? null,
          company_id: me.company_id,
          user_id: authId || null,
        },
      ])
      .select(
        "id, email, name, avatar, role, status, is_online, last_seen, company_id, user_id",
      )
      .single();
    if (error) return res.status(500).json({ error: error.message });
    try {
      io.emit("users:updated", { companyId: me.company_id });
    } catch {}
    return res.status(201).json(inserted);
  } catch (e: any) {
    return res.status(500).json({ error: e?.message || "user create error" });
  }
});

// Update user (same company). Disallow ADMIN role.
app.put("/settings/users/:id", requireAuth, async (req: any, res) => {
  try {
    const { id } = req.params as { id: string };
    const { data: me } = await supabaseAdmin
      .from("users")
      .select("company_id")
      .eq("user_id", req.user.id)
      .maybeSingle();
    if (!me?.company_id)
      return res.status(404).json({ error: "Usu?rio sem company_id" });
    const { data: target } = await supabaseAdmin
      .from("users")
      .select("id, company_id, user_id, email")
      .eq("id", id)
      .maybeSingle();
    if (!target || (target as any).company_id !== me.company_id)
      return res.status(404).json({ error: "Usu?rio n?o encontrado" });
    const schema = z
      .object({
        name: z.string().min(1).optional(),
        email: z.string().email().optional(),
        role: z
          .enum(["AGENT", "SUPERVISOR", "TECHNICIAN", "MANAGER"])
          .optional(),
        avatarUrl: z.string().url().optional(),
        password: z.string().min(6).optional(),
      })
      .passthrough();
    const parsed = schema.safeParse(req.body || {});
    if (!parsed.success)
      return res
        .status(400)
        .json({ error: "Dados inv?lidos", details: parsed.error.format() });
    const b = parsed.data as any;

    // Update auth email/password if needed
    if ((target as any).user_id) {
      if (b.email || b.password) {
        const payload: any = {};
        if (b.email) payload.email = b.email;
        if (b.password) payload.password = b.password;
        const { error: upErr } = await (
          supabaseAdmin as any
        ).auth.admin.updateUserById((target as any).user_id, payload);
        if (upErr) return res.status(400).json({ error: upErr.message });
      }
    }

    const update: any = {};
    if (b.name !== undefined) update.name = b.name;
    if (b.email !== undefined) update.email = b.email;
    if (b.role !== undefined) update.role = b.role;
    if (b.avatarUrl !== undefined) update.avatar = b.avatarUrl;
    update.updated_at = new Date().toISOString();
    const { data: updated, error } = await supabaseAdmin
      .from("users")
      .update(update)
      .eq("id", id)
      .select(
        "id, email, name, avatar, role, status, is_online, last_seen, company_id, user_id",
      )
      .single();
    if (error) return res.status(500).json({ error: error.message });
    try {
      io.emit("users:updated", { companyId: me.company_id });
    } catch {}
    return res.json(updated);
  } catch (e: any) {
    return res.status(500).json({ error: e?.message || "user update error" });
  }
});

// Delete user (and auth user if linked)
app.delete("/settings/users/:id", requireAuth, async (req: any, res) => {
  try {
    const { id } = req.params as { id: string };
    const { data: me } = await supabaseAdmin
      .from("users")
      .select("company_id")
      .eq("user_id", req.user.id)
      .maybeSingle();
    if (!me?.company_id)
      return res.status(404).json({ error: "Usu?rio sem company_id" });
    const { data: target } = await supabaseAdmin
      .from("users")
      .select("id, company_id, user_id")
      .eq("id", id)
      .maybeSingle();
    if (!target || (target as any).company_id !== me.company_id)
      return res.status(404).json({ error: "Usu?rio n?o encontrado" });
    const authId = (target as any).user_id as string | null;
    const { error } = await supabaseAdmin.from("users").delete().eq("id", id);
    if (error) return res.status(500).json({ error: error.message });
    if (authId) {
      try {
        await (supabaseAdmin as any).auth.admin.deleteUser(authId);
      } catch {}
    }
    try {
      io.emit("users:updated", { companyId: me.company_id });
    } catch {}
    return res.status(204).send();
  } catch (e: any) {
    return res.status(500).json({ error: e?.message || "user delete error" });
  }
});

// POST criar coluna (nome + cor)
app.post("/kanban/boards/:boardId/columns", requireAuth, async (req, res) => {
  const { boardId } = req.params as { boardId: string };
  const { name, color } = (req.body || {}) as { name?: string; color?: string };

  if (!name)
    return res.status(400).json({ error: "Campo 'name'   obrigat rio" });

  // pr?xima posi??o dentro do board
  const { data: last, error: errLast } = await supabaseAdmin
    .from("kanban_columns")
    .select("position")
    .eq("kanban_board_id", boardId)
    .order("position", { ascending: false })
    .limit(1)
    .maybeSingle();

  if (errLast) return res.status(500).json({ error: errLast.message });

  const nextPos = (last?.position || 0) + 1;

  const { data, error } = await supabaseAdmin
    .from("kanban_columns")
    .insert([
      {
        kanban_board_id: boardId,
        name,
        color: color || "#6B7280",
        position: nextPos,
      },
    ])
    .select("id, name, color, position")
    .single();

  if (error) return res.status(500).json({ error: error.message });

  const mapped = {
    id: data.id,
    title: data.name,
    color: data.color || "#6B7280",
    position: data.position,
  };
  return res.status(201).json(mapped);
});

const io = new SocketIOServer(server, {
  cors: { origin: FRONTEND_ORIGINS, credentials: true },
});

async function socketAuthUserId(socket: any): Promise<string | null> {
  try {
    const headers = (socket.request?.headers || {}) as any;
    let token: string | undefined;
    const auth =
      (headers["authorization"] as string | undefined) ||
      (headers["Authorization"] as string | undefined);
    if (auth && auth.startsWith("Bearer ")) token = auth.slice(7);
    if (!token) {
      const rawCookie = (headers["cookie"] as string | undefined) || "";
      const parts = rawCookie.split(/;\s*/).map((p) => p.split("="));
      for (const [k, v] of parts) {
        if (k === JWT_COOKIE_NAME && v) {
          token = decodeURIComponent(v);
          break;
        }
      }
    }
    if (!token) return null;
    const { data, error } = await supabaseAdmin.auth.getUser(token);
    if (error || !data?.user?.id) return null;
    return data.user.id as string;
  } catch {
    return null;
  }
}

io.on("connection", (socket) => {
  socket.on("join", ({ chatId }: { chatId: string }) => {
    if (chatId) socket.join(`chat:${chatId}`);
  });
  socket.on("leave", ({ chatId }: { chatId: string }) => {
    if (chatId) socket.leave(`chat:${chatId}`);
  });
  socket.on(
    "message:send",
    async ({
      chatId,
      text,
      senderType = "AGENT",
    }: {
      chatId: string;
      text: string;
      senderType?: string;
    }) => {
      try {
        if (!chatId || !text) return;
        const isFromCustomer = String(senderType).toUpperCase() === "CUSTOMER";
        const nowIso = new Date().toISOString();
        const { data: msg, error } = await supabaseAdmin
          .from("chat_messages")
          .insert([
            {
              chat_id: chatId,
              content: String(text),
              type: "TEXT",
              is_from_customer: isFromCustomer,
              sender_id: null,
              created_at: nowIso,
              view_status: "Sent",
            },
          ])
          .select(
            "id, chat_id, content, is_from_customer, sender_id, created_at, view_status, type",
          )
          .single();
        if (!error && msg) {
          await supabaseAdmin
            .from("chats")
            .update({
              last_message: String(text),
              last_message_at: new Date().toISOString(),
            })
            .eq("id", chatId);
          const mapped = {
            id: msg.id,
            chat_id: msg.chat_id,
            body: msg.content,
            sender_type: msg.is_from_customer ? "CUSTOMER" : "AGENT",
            sender_id: msg.sender_id || null,
            created_at: msg.created_at,
            view_status: msg.view_status || null,
            type: msg.type || "TEXT",
            is_private: false,
          };
          io.to(`chat:${chatId}`).emit("message:new", mapped);
          io.emit("chat:updated", {
            chatId,
            last_message: String(text),
            last_message_at: new Date().toISOString(),
            last_message_from: mapped.sender_type,
          });
        }
      } catch {
        // ignore
      }
    },
  );

  // Fetch authenticated user's inboxes via Socket.IO (ack-based)
  socket.on("livechat:inboxes:my", async (ack?: (resp: any) => void) => {
    try {
      const authUserId = await socketAuthUserId(socket);
      if (!authUserId) return ack?.({ ok: false, error: "Not authenticated" });

      let { data: links, error: errLinks } = await supabaseAdmin
        .from("inbox_users")
        .select("inbox_id")
        .eq("user_id", authUserId);
      if (errLinks) return ack?.({ ok: false, error: errLinks.message });

      if (!links || links.length === 0) {
        try {
          const { data: urow } = await supabaseAdmin
            .from("users")
            .select("id")
            .eq("user_id", authUserId)
            .maybeSingle();
          if (urow?.id) {
            const resp2 = await supabaseAdmin
              .from("inbox_users")
              .select("inbox_id")
              .eq("user_id", urow.id);
            if (!resp2.error) links = resp2.data as any[];
          }
        } catch {}
      }

      const ids = Array.from(
        new Set((links || []).map((r: any) => r.inbox_id)),
      ).filter(Boolean);
      if (ids.length === 0) return ack?.({ ok: true, data: [] });

      const { data, error } = await supabaseAdmin
        .from("inboxes")
        .select("id, name, phone_number, is_active")
        .in("id", ids)
        .eq("is_active", true)
        .order("name", { ascending: true });
      if (error) return ack?.({ ok: false, error: error.message });
      return ack?.({ ok: true, data: data || [] });
    } catch (e: any) {
      return ack?.({ ok: false, error: e?.message || "inboxes fetch error" });
    }
  });

  // List chats
  socket.on(
    "livechat:chats:list",
    async (params: any, ack?: (resp: any) => void) => {
      try {
        const authUserId = await socketAuthUserId(socket);
        if (!authUserId)
          return ack?.({ ok: false, error: "Not authenticated" });

        const inboxId = (params?.inboxId as string) || undefined;
        const status = (params?.status as string) || undefined;
        const q = (params?.q as string) || undefined;
        const limit = params?.limit ? Number(params.limit) : 20;
        const offset = params?.offset ? Number(params.offset) : 0;

        let query = supabaseAdmin
          .from("chats")
          .select(
            "id, external_id, status, last_message, last_message_at, inbox_id, customer_id, assignee_agent",
            { count: "exact" },
          )
          .order("last_message_at", { ascending: false, nullsFirst: false });
        if (inboxId) query = query.eq("inbox_id", inboxId);
        if (status && String(status).toUpperCase() !== "ALL")
          query = query.eq("status", status);
        if (q) query = query.ilike("last_message", `%${q}%`);

        const { data, error, count } = await query.range(
          offset,
          offset + Math.max(0, limit - 1),
        );
        if (error) return ack?.({ ok: false, error: error.message });
        const items = data || [];

        // Enrich from chats.assignee_agent (stores inbox_users.id)
        try {
          const linkIds = Array.from(
            new Set(
              (items as any[])
                .map((c) => (c as any).assignee_agent)
                .filter(Boolean),
            ),
          );
          let userIdByLink: Record<string, string> = {};
          if (linkIds.length > 0) {
            const { data: links } = await supabaseAdmin
              .from("inbox_users")
              .select("id, user_id")
              .in("id", linkIds);
            for (const r of (links as any[]) || [])
              userIdByLink[(r as any).id] = (r as any).user_id;
            const userIds = Array.from(
              new Set(Object.values(userIdByLink).filter(Boolean)),
            );
            let usersById: Record<string, string> = {};
            if (userIds.length > 0) {
              const { data: u } = await supabaseAdmin
                .from("users")
                .select("id, name")
                .in("id", userIds);
              usersById = Object.fromEntries(
                ((u as any[]) || []).map((x) => [x.id, x.name || x.id]),
              );
            }
            for (const it of items as any[]) {
              const linkId = (it as any).assignee_agent || null;
              const uid = linkId ? userIdByLink[linkId] : null;
              (it as any).assigned_agent_id = linkId;
              (it as any).assigned_agent_user_id = uid || null;
              (it as any).assigned_agent_name = uid
                ? usersById[uid] || null
                : null;
            }
          }
        } catch {}

        // Enrich customer display
        try {
          const cids = Array.from(
            new Set(
              (items as any[])
                .map((c) => (c as any).customer_id)
                .filter(Boolean),
            ),
          );
          if (cids.length > 0) {
            const displayById: Record<
              string,
              { name: string | null; phone: string | null }
            > = {};
            async function loadDisplay(table: string, cols: string[]) {
              const sel = ["id", ...cols].join(",");
              const { data: rows } = await supabaseAdmin
                .from(table)
                .select(sel)
                .in("id", cids);
              for (const r of (rows as any[]) || []) {
                const name = (r as any).name || (r as any).title || null;
                const phone =
                  (r as any).phone ||
                  (r as any).cellphone ||
                  (r as any).celular ||
                  (r as any).telefone ||
                  (r as any).contact ||
                  null;
                displayById[(r as any).id] = { name, phone };
              }
            }
            await loadDisplay("customers", [
              "name",
              "phone",
              "cellphone",
              "contact",
            ]).catch(() => {});
            await loadDisplay("customers", [
              "name",
              "celular",
              "telefone",
              "contact",
            ]).catch(() => {});
            await loadDisplay("leads", ["name", "phone", "cellphone"]).catch(
              () => {},
            );
            for (const it of items as any[]) {
              const d = displayById[(it as any).customer_id];
              (it as any).customer_name = d?.name || null;
              (it as any).customer_phone = d?.phone || null;
            }
          }
        } catch {}

        // last sender of last message enrichment (best-effort)
        try {
          const ids = (items as any[]).map((c) => (c as any).id);
          if (ids.length > 0) {
            const { data: msgs } = await supabaseAdmin
              .from("chat_messages")
              .select("chat_id, is_from_customer, sender_type, created_at")
              .in("chat_id", ids)
              .order("created_at", { ascending: false });
            const lastByChat: Record<string, string> = {};
            for (const r of (msgs as any[]) || []) {
              const cid = (r as any).chat_id as string;
              if (lastByChat[cid]) continue;
              const from = (r as any).is_from_customer
                ? "CUSTOMER"
                : (r as any).sender_type || "AGENT";
              lastByChat[cid] = from;
            }
            for (const it of items as any[]) {
              const cid = (it as any).id as string;
              if (lastByChat[cid])
                (it as any).last_message_from = lastByChat[cid];
            }
          }
        } catch {}

        return ack?.({ ok: true, items, total: count ?? (items?.length || 0) });
      } catch (e: any) {
        return ack?.({ ok: false, error: e?.message || "chats list error" });
      }
    },
  );

  // List messages (combined public + private)
  socket.on(
    "livechat:chats:messages",
    async (params: any, ack?: (resp: any) => void) => {
      try {
        const authUserId = await socketAuthUserId(socket);
        if (!authUserId)
          return ack?.({ ok: false, error: "Not authenticated" });
        const chatId = params?.chatId as string;
        if (!chatId) return ack?.({ ok: false, error: "chatId required" });
        const limit = params?.limit ? Number(params.limit) : 50;
        const before = (params?.before as string) || undefined;

        let query = supabaseAdmin
          .from("chat_messages")
          .select(
            "id, chat_id, content, is_from_customer, sender_id, created_at, type, view_status",
          )
          .eq("chat_id", chatId)
          .order("created_at", { ascending: true })
          .limit(limit);
        if (before) query = query.lt("created_at", before);

        const { data, error } = await query;
        if (error && (error as any).code === "42P01")
          return ack?.({ ok: true, data: [] });
        if (error) return ack?.({ ok: false, error: error.message });
        const mappedChat = (data || []).map((r: any) => ({
          id: r.id,
          chat_id: r.chat_id,
          body: r.content,
          sender_type: r.is_from_customer ? "CUSTOMER" : "AGENT",
          sender_id: r.sender_id || null,
          created_at: r.created_at,
          view_status: r.view_status || null,
          type: r.type || "TEXT",
          is_private: false,
        }));

        let mappedPrivate: any[] = [];
        try {
          const { data: privChat } = await supabaseAdmin
            .from("private_chats")
            .select("id")
            .eq("chat_id", chatId)
            .maybeSingle();
          if (privChat?.id) {
            const { data: privMsgs } = await supabaseAdmin
              .from("private_messages")
              .select("id, content, private_chat_id, sender_id, created_at")
              .eq("private_chat_id", privChat.id)
              .order("created_at", { ascending: true });
            const senderIds = Array.from(
              new Set(
                (privMsgs || []).map((r: any) => r.sender_id).filter(Boolean),
              ),
            );
            let nameMap: Record<string, string> = {};
            if (senderIds.length > 0) {
              const { data: usersList } = await supabaseAdmin
                .from("users")
                .select("id, name")
                .in("id", senderIds);
              for (const u of usersList || [])
                nameMap[(u as any).id] = (u as any).name || (u as any).id;
            }
            mappedPrivate = (privMsgs || []).map((r: any) => ({
              id: r.id,
              chat_id: chatId,
              body: r.content,
              sender_type: "AGENT",
              sender_id: r.sender_id || null,
              created_at: r.created_at,
              view_status: null,
              type: "PRIVATE",
              is_private: true,
              sender_name: r.sender_id ? nameMap[r.sender_id] || null : null,
            }));
          }
        } catch {}

        const combined = [...mappedChat, ...mappedPrivate].sort(
          (a, b) =>
            new Date(a.created_at).getTime() - new Date(b.created_at).getTime(),
        );
        return ack?.({ ok: true, data: combined });
      } catch (e: any) {
        return ack?.({ ok: false, error: e?.message || "messages error" });
      }
    },
  );

  // Send file message (base64 payload)
  socket.on("message:file", async (params: any, ack?: (resp: any) => void) => {
    try {
      const authUserId = await socketAuthUserId(socket);
      if (!authUserId) return ack?.({ ok: false, error: "Not authenticated" });
      const id = params?.chatId as string;
      const filename = params?.filename as string;
      const mime = (params?.mime as string) || "application/octet-stream";
      const data = params?.data as string;
      if (!id || !filename || !data)
        return ack?.({
          ok: false,
          error: "chatId, filename and data required",
        });
      const buffer = Buffer.from(
        String(data).replace(/^data:[^;]+;base64,/, ""),
        "base64",
      );
      const ext = filename.includes(".") ? filename.split(".").pop() : "bin";
      const path = `${id}/${Date.now()}_${Math.random().toString(36).slice(2)}.${ext}`;
      try {
        await (supabaseAdmin as any).storage.createBucket("chat-uploads", {
          public: true,
        });
      } catch {}
      const { data: up, error: upErr } = await supabaseAdmin.storage
        .from("chat-uploads")
        .upload(path, buffer, { contentType: mime, upsert: false });
      if (upErr) return ack?.({ ok: false, error: upErr.message });
      const pub = supabaseAdmin.storage
        .from("chat-uploads")
        .getPublicUrl(up!.path);
      const url = (pub as any)?.data?.publicUrl || null;
      const nowIso = new Date().toISOString();
      const kind = mime.startsWith("image/")
        ? "IMAGE"
        : mime.startsWith("audio/")
          ? "AUDIO"
          : "FILE";
      const { data: inserted, error } = await supabaseAdmin
        .from("chat_messages")
        .insert([
          {
            chat_id: id,
            content: String(url || filename),
            type: kind,
            is_from_customer: false,
            sender_id: authUserId,
            created_at: nowIso,
            view_status: "Sent",
          },
        ])
        .select(
          "id, chat_id, content, is_from_customer, sender_id, created_at, view_status, type",
        )
        .single();
      if (error) return ack?.({ ok: false, error: error.message });
      await supabaseAdmin
        .from("chats")
        .update({
          last_message: `[Arquivo] ${filename}`,
          last_message_at: nowIso,
        })
        .eq("id", id);
      const mapped = {
        id: inserted.id,
        chat_id: inserted.chat_id,
        body: inserted.content,
        sender_type: inserted.is_from_customer ? "CUSTOMER" : "AGENT",
        sender_id: inserted.sender_id || null,
        created_at: inserted.created_at,
        view_status: inserted.view_status || null,
        type: inserted.type || kind,
        is_private: false,
      };
      io.to(`chat:${id}`).emit("message:new", mapped);
      io.emit("chat:updated", {
        chatId: id,
        last_message: `[Arquivo] ${filename}`,
        last_message_at: nowIso,
        last_message_from: mapped.sender_type,
      });
      return ack?.({ ok: true, data: mapped });
    } catch (e: any) {
      return ack?.({ ok: false, error: e?.message || "upload error" });
    }
  });

  // Send private message
  socket.on(
    "message:private:send",
    async (params: any, ack?: (resp: any) => void) => {
      try {
        const authUserId = await socketAuthUserId(socket);
        if (!authUserId)
          return ack?.({ ok: false, error: "Not authenticated" });
        const id = params?.chatId as string;
        const text = (params?.text as string) || "";
        if (!id || !text)
          return ack?.({ ok: false, error: "chatId and text required" });

        // resolve local users.id
        let localUserId: string | null = null;
        try {
          const { data: urow } = await supabaseAdmin
            .from("users")
            .select("id")
            .eq("user_id", authUserId)
            .maybeSingle();
          localUserId = (urow as any)?.id || null;
        } catch {}
        // ensure private_chat
        let privateChatId: string | null = null;
        const { data: existing } = await supabaseAdmin
          .from("private_chats")
          .select("id")
          .eq("chat_id", id)
          .maybeSingle();
        if (existing?.id) privateChatId = existing.id;
        else {
          const { data: created, error: errCreate } = await supabaseAdmin
            .from("private_chats")
            .insert([{ chat_id: id, is_active: true }])
            .select("id")
            .single();
          if (errCreate) return ack?.({ ok: false, error: errCreate.message });
          privateChatId = (created as any)?.id || null;
        }
        if (!privateChatId)
          return ack?.({ ok: false, error: "failed create private_chat" });

        const nowIso = new Date().toISOString();
        const { data: inserted, error } = await supabaseAdmin
          .from("private_messages")
          .insert([
            {
              content: String(text),
              private_chat_id: privateChatId,
              sender_id: localUserId || authUserId,
              created_at: nowIso,
            },
          ])
          .select("id, content, sender_id, created_at")
          .single();
        if (error) return ack?.({ ok: false, error: error.message });

        let senderName: string | null = null;
        if (localUserId) {
          try {
            const { data: u } = await supabaseAdmin
              .from("users")
              .select("name")
              .eq("id", localUserId)
              .maybeSingle();
            senderName = (u as any)?.name || null;
          } catch {}
        }
        const mapped = {
          id: inserted.id,
          chat_id: id,
          body: inserted.content,
          sender_type: "AGENT",
          sender_id: inserted.sender_id || null,
          created_at: inserted.created_at,
          view_status: null,
          type: "PRIVATE",
          is_private: true,
          sender_name: senderName,
        };
        io.to(`chat:${id}`).emit("message:new", mapped);
        return ack?.({ ok: true, data: mapped });
      } catch (e: any) {
        return ack?.({ ok: false, error: e?.message || "private send error" });
      }
    },
  );

  // Chat tags get/set
  socket.on(
    "livechat:chats:tags:get",
    async (params: any, ack?: (resp: any) => void) => {
      try {
        const authUserId = await socketAuthUserId(socket);
        if (!authUserId)
          return ack?.({ ok: false, error: "Not authenticated" });
        const id = params?.chatId as string;
        if (!id) return ack?.({ ok: false, error: "chatId required" });
        const { data, error } = await supabaseAdmin
          .from("chat_tags")
          .select("tag_id")
          .eq("chat_id", id);
        if (error) return ack?.({ ok: false, error: error.message });
        return ack?.({
          ok: true,
          data: ((data as any[]) || []).map((r: any) => r.tag_id),
        });
      } catch (e: any) {
        return ack?.({ ok: false, error: e?.message || "tags list error" });
      }
    },
  );
  socket.on(
    "livechat:chats:tags:set",
    async (params: any, ack?: (resp: any) => void) => {
      try {
        const authUserId = await socketAuthUserId(socket);
        if (!authUserId)
          return ack?.({ ok: false, error: "Not authenticated" });
        const id = params?.chatId as string;
        const tagIds: string[] = Array.isArray(params?.tags) ? params.tags : [];
        if (!id) return ack?.({ ok: false, error: "chatId required" });
        const { error: errDel } = await supabaseAdmin
          .from("chat_tags")
          .delete()
          .eq("chat_id", id);
        if (errDel) return ack?.({ ok: false, error: errDel.message });
        if (tagIds.length > 0) {
          // Load company board
          const { data: urow } = await supabaseAdmin
            .from("users")
            .select("company_id")
            .eq("user_id", authUserId)
            .maybeSingle();
          const companyId = (urow as any)?.company_id;
          let boardId: string | null = null;
          if (companyId) {
            const { data: board } = await supabaseAdmin
              .from("kanban_boards")
              .select("id, is_default, created_at")
              .eq("company_id", companyId)
              .order("is_default", { ascending: false })
              .order("created_at", { ascending: true })
              .limit(1)
              .maybeSingle();
            boardId = (board as any)?.id || null;
          }
          const { data: tagRows } = await supabaseAdmin
            .from("tags")
            .select("id, name, color")
            .in("id", tagIds);
          const rowsToInsert: any[] = [];
          for (const t of (tagRows as any[]) || []) {
            let columnId: string | null = null;
            if (boardId) {
              const { data: col } = await supabaseAdmin
                .from("kanban_columns")
                .select("id")
                .eq("kanban_board_id", boardId)
                .eq("name", (t as any).name)
                .maybeSingle();
              columnId = (col as any)?.id || null;
              if (!columnId) {
                const { data: last } = await supabaseAdmin
                  .from("kanban_columns")
                  .select("position")
                  .eq("kanban_board_id", boardId)
                  .order("position", { ascending: false })
                  .limit(1)
                  .maybeSingle();
                const nextPos = ((last as any)?.position || 0) + 1;
                const { data: created } = await supabaseAdmin
                  .from("kanban_columns")
                  .insert([
                    {
                      name: (t as any).name,
                      color: (t as any).color || null,
                      position: nextPos,
                      kanban_board_id: boardId,
                    },
                  ])
                  .select("id")
                  .single();
                columnId = (created as any)?.id || null;
              }
            }
            if (!columnId)
              return ack?.({
                ok: false,
                error: "Nenhuma coluna/board dispon?vel para vincular a tag",
              });
            rowsToInsert.push({
              chat_id: id,
              tag_id: (t as any).id,
              kanban_colum_id: columnId,
            });
          }
          const { error } = await supabaseAdmin
            .from("chat_tags")
            .insert(rowsToInsert);
          if (error) return ack?.({ ok: false, error: error.message });
        }
        try {
          io.to(`chat:${id}`).emit("chat:tags", { chatId: id, tags: tagIds });
        } catch {}
        return ack?.({ ok: true, count: tagIds.length });
      } catch (e: any) {
        return ack?.({ ok: false, error: e?.message || "tags set error" });
      }
    },
  );

  // Assignee set
  socket.on(
    "livechat:chats:assignee:set",
    async (params: any, ack?: (resp: any) => void) => {
      const id = params?.chatId as string;
      const linkIdParam = (params?.linkId as string | null) ?? null;
      const userIdParam = (params?.userId as string | null) ?? null;
      try {
        const authUserId = await socketAuthUserId(socket);
        if (!authUserId)
          return ack?.({ ok: false, error: "Not authenticated" });
        const { data: chat, error: errChat } = await supabaseAdmin
          .from("chats")
          .select("id, inbox_id")
          .eq("id", id)
          .maybeSingle();
        if (errChat) return ack?.({ ok: false, error: errChat.message });
        if (!chat) return ack?.({ ok: false, error: "Chat not found" });

        let actingUserLocalId: string | null = null;
        try {
          const { data: urow } = await supabaseAdmin
            .from("users")
            .select("id")
            .eq("user_id", authUserId)
            .maybeSingle();
          actingUserLocalId = (urow as any)?.id || null;
        } catch {}
        if (actingUserLocalId) {
          const { data: linkAct } = await supabaseAdmin
            .from("inbox_users")
            .select("can_write, can_manage")
            .eq("inbox_id", (chat as any).inbox_id)
            .eq("user_id", actingUserLocalId)
            .maybeSingle();
          if (!linkAct || (!linkAct.can_write && !linkAct.can_manage)) {
            return ack?.({
              ok: false,
              error: "Sem permissao para atribuir nesta inbox",
            });
          }
        }
        // Resolve link id
        let targetLinkId: string | null = linkIdParam;
        if (!targetLinkId && userIdParam) {
          const { data: l } = await supabaseAdmin
            .from("inbox_users")
            .select("id")
            .eq("inbox_id", (chat as any).inbox_id)
            .eq("user_id", userIdParam)
            .maybeSingle();
          targetLinkId = (l as any)?.id || null;
        }
        if (!targetLinkId)
          return ack?.({
            ok: false,
            error: "linkId ou userId inv?lido para esta inbox",
          });

        // Validate link belongs to this inbox and fetch user
        const { data: linkRow } = await supabaseAdmin
          .from("inbox_users")
          .select("id, user_id, inbox_id")
          .eq("id", targetLinkId)
          .maybeSingle();
        if (!linkRow || (linkRow as any).inbox_id !== (chat as any).inbox_id) {
          return ack?.({ ok: false, error: "Link n?o pertence ? inbox" });
        }

        await supabaseAdmin
          .from("chats")
          .update({ assignee_agent: targetLinkId })
          .eq("id", id);

        let assignedName: string | null = null;
        try {
          const uid = (linkRow as any).user_id;
          const { data: u } = await supabaseAdmin
            .from("users")
            .select("id, name")
            .eq("id", uid)
            .maybeSingle();
          assignedName = (u as any)?.name || null;
        } catch {}
        io.emit("chat:updated", {
          chatId: id,
          assigned_agent_id: targetLinkId,
          assigned_agent_name: assignedName,
        });
        return ack?.({
          ok: true,
          assigned_agent_id: targetLinkId,
          assigned_agent_name: assignedName,
        });
      } catch (e: any) {
        return ack?.({
          ok: false,
          error: e?.message || "Falha ao definir responsavel",
        });
      }
    },
  );

  // Participants list/add/remove
  socket.on(
    "livechat:chats:participants:list",
    async (params: any, ack?: (resp: any) => void) => {
      try {
        const authUserId = await socketAuthUserId(socket);
        if (!authUserId)
          return ack?.({ ok: false, error: "Not authenticated" });
        const id = params?.chatId as string;
        if (!id) return ack?.({ ok: false, error: "chatId required" });
        const { data: rows, error } = await supabaseAdmin
          .from("chat_participants")
          .select("user_id, joined_at, left_at, is_active")
          .eq("chat_id", id);
        if (error) return ack?.({ ok: false, error: error.message });
        const uids = Array.from(
          new Set((rows || []).map((r: any) => r.user_id).filter(Boolean)),
        );
        let usersMap: Record<
          string,
          { name: string | null; role: string | null; user_id: string | null }
        > = {};
        if (uids.length > 0) {
          const { data: users } = await supabaseAdmin
            .from("users")
            .select("id, user_id, name, role")
            .in("id", uids);
          for (const u of users || [])
            usersMap[(u as any).id] = {
              name: (u as any).name || (u as any).id,
              role: (u as any).role || null,
              user_id: (u as any).user_id || null,
            };
        }
        const list = (rows || []).map((r: any) => ({
          id: r.user_id,
          name: usersMap[r.user_id]?.name || r.user_id,
          role: usersMap[r.user_id]?.role || null,
          is_current: usersMap[r.user_id]?.user_id === authUserId,
        }));
        return ack?.({ ok: true, data: list });
      } catch (e: any) {
        return ack?.({ ok: false, error: e?.message || "participants error" });
      }
    },
  );
  socket.on(
    "livechat:chats:participants:add",
    async (params: any, ack?: (resp: any) => void) => {
      try {
        const authUserId = await socketAuthUserId(socket);
        if (!authUserId)
          return ack?.({ ok: false, error: "Not authenticated" });
        const id = params?.chatId as string;
        const userId = params?.userId as string;
        if (!id || !userId)
          return ack?.({ ok: false, error: "chatId and userId required" });
        const nowIso = new Date().toISOString();
        const { data, error } = await supabaseAdmin
          .from("chat_participants")
          .upsert(
            [
              {
                chat_id: id,
                user_id: userId,
                is_active: true,
                left_at: null,
                joined_at: nowIso,
              },
            ],
            { onConflict: "chat_id,user_id" },
          )
          .select("*")
          .single();
        if (error) return ack?.({ ok: false, error: error.message });
        return ack?.({ ok: true, data });
      } catch (e: any) {
        return ack?.({
          ok: false,
          error: e?.message || "participants add error",
        });
      }
    },
  );
  socket.on(
    "livechat:chats:participants:remove",
    async (params: any, ack?: (resp: any) => void) => {
      try {
        const authUserId = await socketAuthUserId(socket);
        if (!authUserId)
          return ack?.({ ok: false, error: "Not authenticated" });
        const id = params?.chatId as string;
        const userId = params?.userId as string;
        if (!id || !userId)
          return ack?.({ ok: false, error: "chatId and userId required" });
        const { error } = await supabaseAdmin
          .from("chat_participants")
          .update({ is_active: false, left_at: new Date().toISOString() })
          .eq("chat_id", id)
          .eq("user_id", userId);
        if (error) return ack?.({ ok: false, error: error.message });
        return ack?.({ ok: true });
      } catch (e: any) {
        return ack?.({
          ok: false,
          error: e?.message || "participants remove error",
        });
      }
    },
  );

  // Agents listing
  socket.on(
    "livechat:inboxes:agents",
    async (params: any, ack?: (resp: any) => void) => {
      try {
        const authUserId = await socketAuthUserId(socket);
        if (!authUserId)
          return ack?.({ ok: false, error: "Not authenticated" });
        const inboxId = params?.inboxId as string;
        if (!inboxId) return ack?.({ ok: false, error: "inboxId required" });
        const { data: links, error: errLinks } = await supabaseAdmin
          .from("inbox_users")
          .select("id, user_id")
          .eq("inbox_id", inboxId);
        if (errLinks) return ack?.({ ok: false, error: errLinks.message });
        const raw = (links || []) as any[];
        const rawIds = Array.from(
          new Set(raw.map((r: any) => r.user_id).filter(Boolean)),
        );
        if (rawIds.length === 0) return ack?.({ ok: true, data: [] });
        const { data: users } = await supabaseAdmin
          .from("users")
          .select("id, user_id, name, role")
          .in("id", rawIds)
          .order("name", { ascending: true });
        const byUser: Record<string, any> = Object.fromEntries(
          ((users as any[]) || []).map((u: any) => [u.id, u]),
        );
        const result = raw
          .map((link: any) => {
            const u = byUser[link.user_id];
            if (!u) return null;
            return {
              id: link.id,
              user_id: u.id,
              name: u.name || u.id,
              role: u.role,
            };
          })
          .filter(Boolean);
        return ack?.({ ok: true, data: result });
      } catch (e: any) {
        return ack?.({ ok: false, error: e?.message || "inbox agents error" });
      }
    },
  );
  socket.on(
    "users:agents-supervisors",
    async (_params: any, ack?: (resp: any) => void) => {
      try {
        const authUserId = await socketAuthUserId(socket);
        if (!authUserId)
          return ack?.({ ok: false, error: "Not authenticated" });
        const { data: userRow, error: errUser } = await supabaseAdmin
          .from("users")
          .select("company_id")
          .eq("user_id", authUserId)
          .maybeSingle();
        if (errUser) return ack?.({ ok: false, error: errUser.message });
        if (!userRow?.company_id)
          return ack?.({ ok: false, error: "Usu?rio sem company_id" });
        const { data, error } = await supabaseAdmin
          .from("users")
          .select("id, user_id, name, role")
          .eq("company_id", (userRow as any).company_id)
          .in("role", ["AGENT", "SUPERVISOR"])
          .order("name", { ascending: true });
        if (error) return ack?.({ ok: false, error: error.message });
        return ack?.({
          ok: true,
          data: (data || []).map((u: any) => ({
            id: u.id,
            name: u.name || u.id,
            role: u.role,
          })),
        });
      } catch (e: any) {
        return ack?.({ ok: false, error: e?.message || "agents list error" });
      }
    },
  );

  // Company tags list
  socket.on(
    "livechat:tags:list",
    async (_params: any, ack?: (resp: any) => void) => {
      try {
        const authUserId = await socketAuthUserId(socket);
        if (!authUserId)
          return ack?.({ ok: false, error: "Not authenticated" });
        const { data: urow, error: errU } = await supabaseAdmin
          .from("users")
          .select("company_id")
          .eq("user_id", authUserId)
          .maybeSingle();
        if (errU) return ack?.({ ok: false, error: errU.message });
        if (!urow?.company_id)
          return ack?.({ ok: false, error: "Usu?rio sem company_id" });
        const { data, error } = await supabaseAdmin
          .from("tags")
          .select("id, name, color, created_at, updated_at")
          .eq("company_id", (urow as any).company_id)
          .order("name", { ascending: true });
        if (error) return ack?.({ ok: false, error: error.message });
        return ack?.({ ok: true, data: data || [] });
      } catch (e: any) {
        return ack?.({ ok: false, error: e?.message || "tags list error" });
      }
    },
  );
});

// ===== Company profile (current user's company) =====
// GET current user's company data
app.get("/companies/me", requireAuth, async (req: any, res) => {
  try {
    const authUserId = req.user.id as string;
    const { data: urow, error: uerr } = await supabaseAdmin
      .from("users")
      .select("company_id")
      .eq("user_id", authUserId)
      .maybeSingle();
    if (uerr) return res.status(500).json({ error: uerr.message });
    const companyId = (urow as any)?.company_id as string | null;
    if (!companyId)
      return res.status(404).json({ error: "Usu?rio sem company_id" });

    const { data: comp, error: cerr } = await supabaseAdmin
      .from("companies")
      .select(
        "id, name, cnpj, email, phone, address, city, state, zip_code, logo, plan, is_active, created_at, updated_at",
      )
      .eq("id", companyId)
      .maybeSingle();
    if (cerr) return res.status(500).json({ error: cerr.message });
    if (!comp) return res.status(404).json({ error: "Empresa n?o encontrada" });
    return res.json(comp);
  } catch (e: any) {
    return res.status(500).json({ error: e?.message || "company get error" });
  }
});

// PUT update current user's company data (partial)
app.put("/companies/me", requireAuth, async (req: any, res) => {
  try {
    const authUserId = req.user.id as string;
    const { data: urow, error: uerr } = await supabaseAdmin
      .from("users")
      .select("company_id")
      .eq("user_id", authUserId)
      .maybeSingle();
    if (uerr) return res.status(500).json({ error: uerr.message });
    const companyId = (urow as any)?.company_id as string | null;
    if (!companyId)
      return res.status(404).json({ error: "Usu?rio sem company_id" });

    // Validate and pick only allowed fields
    const schema = z
      .object({
        name: z.string().min(1).optional(),
        cnpj: z.string().min(1).optional(),
        email: z.string().email().optional(),
        phone: z.string().min(3).optional(),
        address: z.string().optional().nullable(),
        city: z.string().optional().nullable(),
        state: z.string().optional().nullable(),
        zip_code: z.string().optional().nullable(),
        logo: z.string().url().optional().nullable(),
        // plan/is_active are intentionally not exposed here
      })
      .passthrough();
    const parsed = schema.safeParse(req.body || {});
    if (!parsed.success) {
      return res
        .status(400)
        .json({ error: "Dados inv?lidos", details: parsed.error.format() });
    }
    const body = parsed.data as any;
    const update: Record<string, any> = {};
    const fields = [
      "name",
      "cnpj",
      "email",
      "phone",
      "address",
      "city",
      "state",
      "zip_code",
      "logo",
    ] as const;
    for (const k of fields)
      if (Object.prototype.hasOwnProperty.call(body, k)) update[k] = body[k];
    update.updated_at = new Date().toISOString();
    if (Object.keys(update).length === 1 && update.updated_at) {
      return res.status(400).json({ error: "Nada para atualizar" });
    }

    const { data: updated, error } = await supabaseAdmin
      .from("companies")
      .update(update)
      .eq("id", companyId)
      .select(
        "id, name, cnpj, email, phone, address, city, state, zip_code, logo, plan, is_active, created_at, updated_at",
      )
      .single();
    if (error) return res.status(500).json({ error: error.message });

    try {
      io.emit("company:updated", {
        companyId,
        changes: update,
        company: updated,
      });
    } catch {}

    return res.json(updated);
  } catch (e: any) {
    return res
      .status(500)
      .json({ error: e?.message || "company update error" });
  }
});

// ===== Proposals =====
app.get("/proposals", requireAuth, async (req: any, res) => {
  try {
    // Load local user row to get company
    const { data: urow, error: uerr } = await supabaseAdmin
      .from("users")
      .select("id, company_id")
      .eq("user_id", req.user.id)
      .maybeSingle();
    if (uerr) return res.status(500).json({ error: uerr.message });
    const companyId = (urow as any)?.company_id || null;

    if (!companyId) return res.json([]);

    const leadFilter = (req.query.leadId as string | undefined)?.trim();

    let query = supabaseAdmin
      .from("proposals")
      .select(
        "id, number, title, description, total_value, status, valid_until, created_at, customer_id, ai_generated, lead_id",
      )
      .eq("company_id", companyId)
      .order("created_at", { ascending: false });

    if (leadFilter) query = query.eq("lead_id", leadFilter);

    const { data, error } = await query;
    if (error) return res.status(500).json({ error: error.message });
    return res.json(data || []);
  } catch (e: any) {
    return res
      .status(500)
      .json({ error: e?.message || "Proposals list error" });
  }
});

// Create proposal
app.post("/proposals", requireAuth, async (req: any, res) => {
  try {
    const authUserId = req.user.id as string;
    const { data: urow, error: uerr } = await supabaseAdmin
      .from("users")
      .select("id, company_id")
      .eq("user_id", authUserId)
      .maybeSingle();
    if (uerr) return res.status(500).json({ error: uerr.message });
    if (!urow?.company_id)
      return res.status(404).json({ error: "Usu rio sem company_id" });

    const body = req.body || {};
    let customerId: string | null = body.customer_id || null;
    const leadId: string | null = body.lead_id || null;

    if (!customerId && leadId) {
      try {
        const { data: cust } = await supabaseAdmin
          .from("customers")
          .select("id")
          .eq("lead_id", leadId)
          .maybeSingle();
        customerId = (cust as any)?.id || null;
      } catch {}
      if (!customerId) {
        const { data: l } = await supabaseAdmin
          .from("leads")
          .select("id, name, email")
          .eq("id", leadId)
          .maybeSingle();
        const payload: any = {
          company_id: (urow as any).company_id,
          name: (l as any)?.name || "Cliente",
          email: (l as any)?.email || null,
        };
        try {
          payload.lead_id = leadId;
          const { data: created } = await supabaseAdmin
            .from("customers")
            .insert([payload])
            .select("id")
            .single();
          customerId = (created as any)?.id || null;
        } catch {
          delete payload.lead_id;
          const { data: created2 } = await supabaseAdmin
            .from("customers")
            .insert([payload])
            .select("id")
            .single();
          customerId = (created2 as any)?.id || null;
        }
      }
    }

    if (!customerId)
      return res
        .status(400)
        .json({ error: "customer_id ou lead_id obrigat rio" });

    const now = new Date();
    const pad = (n: number) => n.toString().padStart(2, "0");
    const num =
      "P-" +
      now.getFullYear().toString() +
      pad(now.getMonth() + 1) +
      pad(now.getDate()) +
      "-" +
      pad(now.getHours()) +
      pad(now.getMinutes()) +
      pad(now.getSeconds());

    const sysPower = Number(body.system_power ?? 0) || 0;
    const panelQty = Number(body.panel_quantity ?? 1) || 1;
    const totalValue = Number(body.total_value ?? 0) || 0;
    const title = String(body.title || "Proposta");
    const description = body.description ?? null;
    const installments = body.installments ?? 1;
    const installmentValue = body.installment_value ?? null;
    const validDays = Number(body.valid_days ?? 30) || 30;
    const validUntil = new Date(now.getTime() + validDays * 24 * 60 * 60 * 1000)
      .toISOString()
      .slice(0, 10);

    const insert: any = {
      number: num,
      title,
      description,
      system_power: sysPower,
      panel_quantity: panelQty,
      total_value: totalValue,
      installments,
      installment_value: installmentValue,
      valid_until: validUntil,
      status: body.status || "DRAFT",
      ai_generated: !!body.ai_generated,
      company_id: (urow as any).company_id,
      customer_id: customerId,
      lead_id: leadId,
      created_by_id: (urow as any).id,
    };

    const { data, error } = await supabaseAdmin
      .from("proposals")
      .insert([insert])
      .select("id")
      .single();
    if (error) return res.status(500).json({ error: error.message });
    try {
      io.emit("proposals:changed", { type: "created", id: (data as any).id });
    } catch {}
    return res.status(201).json({ id: (data as any).id, number: num });
  } catch (e: any) {
    return res
      .status(500)
      .json({ error: e?.message || "Create proposal error" });
  }
});

// Edit proposal (partial update)
app.patch("/proposals/:id", requireAuth, async (req: any, res) => {
  try {
    const authUserId = req.user.id as string;
    const { data: urow, error: uerr } = await supabaseAdmin
      .from("users")
      .select("id, company_id")
      .eq("user_id", authUserId)
      .maybeSingle();
    if (uerr) return res.status(500).json({ error: uerr.message });
    const companyId = (urow as any)?.company_id || null;
    if (!companyId)
      return res.status(404).json({ error: "Usu rio sem company_id" });

    const { id } = req.params as { id: string };
    const { data: prop, error: perr } = await supabaseAdmin
      .from("proposals")
      .select("id, company_id")
      .eq("id", id)
      .maybeSingle();
    if (perr) return res.status(500).json({ error: perr.message });
    if (!prop || (prop as any).company_id !== companyId)
      return res.status(404).json({ error: "Proposta n o encontrada" });

    const body = req.body || {};
    const up: Record<string, any> = {};
    const fields = [
      "title",
      "description",
      "system_power",
      "panel_quantity",
      "total_value",
      "installments",
      "installment_value",
      "valid_until",
      "status",
    ] as const;
    for (const k of fields)
      if (Object.prototype.hasOwnProperty.call(body, k))
        up[k] = (body as any)[k];
    if (Object.keys(up).length === 0)
      return res.status(400).json({ error: "Nada para atualizar" });

    const { error } = await supabaseAdmin
      .from("proposals")
      .update(up)
      .eq("id", id);
    if (error) return res.status(500).json({ error: error.message });
    try {
      io.emit("proposals:changed", { type: "updated", id });
    } catch {}
    return res.status(204).send();
  } catch (e: any) {
    return res
      .status(500)
      .json({ error: e?.message || "Update proposal error" });
  }
});

// Update proposal status
app.patch("/proposals/:id/status", requireAuth, async (req: any, res) => {
  try {
    const authUserId = req.user.id as string;
    // Resolve local user row to get company
    const { data: urow, error: uerr } = await supabaseAdmin
      .from("users")
      .select("id, company_id")
      .eq("user_id", authUserId)
      .maybeSingle();
    if (uerr) return res.status(500).json({ error: uerr.message });
    const companyId = (urow as any)?.company_id || null;
    if (!companyId)
      return res.status(404).json({ error: "Usu rio sem company_id" });

    const { id } = req.params as { id: string };
    const status = String(req.body?.status ?? "").trim();
    if (!status) return res.status(400).json({ error: "status obrigat rio" });

    // Optional: restrict to known statuses
    const allowed = new Set([
      "DRAFT",
      "SENT",
      "ACCEPTED",
      "REJECTED",
      "CANCELLED",
      "APPROVED",
    ]);
    if (!allowed.has(status.toUpperCase())) {
      return res.status(400).json({ error: "status inv lido" });
    }

    // Ensure proposal belongs to same company
    const { data: prop, error: perr } = await supabaseAdmin
      .from("proposals")
      .select("id, company_id")
      .eq("id", id)
      .maybeSingle();
    if (perr) return res.status(500).json({ error: perr.message });
    if (!prop || (prop as any).company_id !== companyId) {
      return res.status(404).json({ error: "Proposta n o encontrada" });
    }

    const { error } = await supabaseAdmin
      .from("proposals")
      .update({ status })
      .eq("id", id);
    if (error) return res.status(500).json({ error: error.message });
    try {
      io.emit("proposals:changed", { type: "updated", id });
    } catch {}
    return res.status(204).send();
  } catch (e: any) {
    return res
      .status(500)
      .json({ error: e?.message || "Update proposal status error" });
  }
});

// Duplicate proposal
app.post("/proposals/:id/duplicate", requireAuth, async (req: any, res) => {
  try {
    const authUserId = req.user.id as string;
    const { data: urow, error: uerr } = await supabaseAdmin
      .from("users")
      .select("id, company_id")
      .eq("user_id", authUserId)
      .maybeSingle();
    if (uerr) return res.status(500).json({ error: uerr.message });
    const companyId = (urow as any)?.company_id || null;
    if (!companyId)
      return res.status(404).json({ error: "Usu rio sem company_id" });

    const { id } = req.params as { id: string };
    const { data: src, error: serr } = await supabaseAdmin
      .from("proposals")
      .select(
        "id, number, title, description, system_power, panel_quantity, total_value, installments, installment_value, valid_until, status, customer_id, lead_id, ai_generated, company_id",
      )
      .eq("id", id)
      .maybeSingle();
    if (serr) return res.status(500).json({ error: serr.message });
    if (!src || (src as any).company_id !== companyId)
      return res.status(404).json({ error: "Proposta n o encontrada" });

    // Generate new sequential-like number (YYYYMM-####)
    const now = new Date();
    const pad = (n: number) => n.toString().padStart(2, "0");
    const ym = `${now.getFullYear()}${pad(now.getMonth() + 1)}`;
    const { data: last } = await supabaseAdmin
      .from("proposals")
      .select("number")
      .like("number", `${ym}-%`)
      .order("number", { ascending: false })
      .limit(1);
    let seq = 1;
    const lastNum =
      Array.isArray(last) && (last as any)[0]?.number
        ? String((last as any)[0].number)
        : null;
    if (lastNum && /^\d{6}-\d{4}$/.test(lastNum)) {
      seq = (parseInt(lastNum.slice(-4)) || 0) + 1;
    }
    const newNumber = `${ym}-${seq.toString().padStart(4, "0")}`;

    // Calculate new valid_until: keep same days delta if possible (default +30d)
    const baseValidDays = (() => {
      try {
        const srcDate = (src as any).valid_until
          ? new Date((src as any).valid_until)
          : null;
        if (srcDate && !isNaN(srcDate.getTime())) {
          const diffMs = srcDate.getTime() - now.getTime();
          const days = Math.max(1, Math.round(diffMs / (24 * 60 * 60 * 1000)));
          return days;
        }
      } catch {}
      return 30;
    })();
    const newValidUntil = new Date(
      now.getTime() + baseValidDays * 24 * 60 * 60 * 1000,
    )
      .toISOString()
      .slice(0, 10);

    const insert: any = {
      number: newNumber,
      title: `${(src as any).title || "Proposta"} (C pia)`,
      description: (src as any).description ?? null,
      system_power: (src as any).system_power ?? null,
      panel_quantity: (src as any).panel_quantity ?? 1,
      total_value: (src as any).total_value ?? 0,
      installments: (src as any).installments ?? 1,
      installment_value: (src as any).installment_value ?? null,
      valid_until: newValidUntil,
      status: "DRAFT",
      ai_generated: false,
      company_id: companyId,
      customer_id: (src as any).customer_id ?? null,
      lead_id: (src as any).lead_id ?? null,
      created_by_id: (urow as any).id,
    };

    const { data: created, error: cerr } = await supabaseAdmin
      .from("proposals")
      .insert([insert])
      .select("id, number")
      .single();
    if (cerr) return res.status(500).json({ error: cerr.message });
    try {
      io.emit("proposals:changed", {
        type: "created",
        id: (created as any).id,
      });
    } catch {}
    return res
      .status(201)
      .json({ id: (created as any).id, number: (created as any).number });
  } catch (e: any) {
    return res
      .status(500)
      .json({ error: e?.message || "Duplicate proposal error" });
  }
});

// Delete proposal
app.delete("/proposals/:id", requireAuth, async (req: any, res) => {
  try {
    const authUserId = req.user.id as string;
    const { data: urow, error: uerr } = await supabaseAdmin
      .from("users")
      .select("id, company_id")
      .eq("user_id", authUserId)
      .maybeSingle();
    if (uerr) return res.status(500).json({ error: uerr.message });
    const companyId = (urow as any)?.company_id || null;
    if (!companyId)
      return res.status(404).json({ error: "Usu rio sem company_id" });

    const { id } = req.params as { id: string };
    const { data: prop, error: perr } = await supabaseAdmin
      .from("proposals")
      .select("id, company_id")
      .eq("id", id)
      .maybeSingle();
    if (perr) return res.status(500).json({ error: perr.message });
    if (!prop || (prop as any).company_id !== companyId)
      return res.status(404).json({ error: "Proposta n o encontrada" });

    // Delete linked documents (by metadata.proposal_id) first
    try {
      await supabaseAdmin
        .from("documents")
        .delete()
        .eq("company_id", companyId)
        .eq("proposta_id", id);
    } catch {}
    const { error } = await supabaseAdmin
      .from("proposals")
      .delete()
      .eq("id", id);
    if (error) return res.status(500).json({ error: error.message });
    try {
      io.emit("proposals:changed", { type: "deleted", id });
    } catch {}
    return res.status(204).send();
  } catch (e: any) {
    return res
      .status(500)
      .json({ error: e?.message || "Delete proposal error" });
  }
});
// ===== Documents =====
const DOCS_BUCKET = process.env.DOCS_BUCKET || "documents";

// List documents for current user's company
app.get("/documents", requireAuth, async (req: any, res) => {
  try {
    const { data: urow, error: uerr } = await supabaseAdmin
      .from("users")
      .select("id, company_id")
      .eq("user_id", req.user.id)
      .maybeSingle();
    if (uerr) return res.status(500).json({ error: uerr.message });
    const companyId = (urow as any)?.company_id || null;
    if (!companyId) return res.json([]);

    const customerId = (req.query.customer_id as string | undefined)?.trim();
    const docType = (req.query.doc_type as string | undefined)?.trim();

    let query = supabaseAdmin
      .from("documents")
      .select(
        "id, customer_id, proposta_id, doc_type, status, number, series, full_number, total, issued_at, due_at, created_at, pdf_path",
      )
      .eq("company_id", companyId)
      .order("created_at", { ascending: false });

    if (customerId) query = query.eq("customer_id", customerId);
    if (docType) query = query.eq("doc_type", docType);

    const { data, error } = await query;
    if (error) return res.status(500).json({ error: error.message });

    const items = (data || []).map((d: any) => ({
      id: d.id,
      customer_id: d.customer_id,
      proposta_id: d.proposta_id || null,
      doc_type: d.doc_type,
      status: d.status,
      number: d.number,
      series: d.series,
      full_number:
        d.full_number ||
        (d.series
          ? String(d.series) + "-" + String(d.number)
          : (d.number ?? "")),
      total: d.total,
      issued_at: d.issued_at,
      due_at: d.due_at,
      created_at: d.created_at,
      has_pdf: !!d.pdf_path,
    }));
    return res.json(items);
  } catch (e: any) {
    return res
      .status(500)
      .json({ error: e?.message || "Documents list error" });
  }
});
// Download document PDF (redirect to signed URL)
app.get("/documents/:id/download", requireAuth, async (req: any, res) => {
  try {
    const { id } = req.params as { id: string };
    const { data, error } = await supabaseAdmin
      .from("documents")
      .select("pdf_path")
      .eq("id", id)
      .maybeSingle();
    if (error) return res.status(500).json({ error: error.message });
    const pdfPath = (data as any)?.pdf_path as string | null;
    if (!pdfPath) return res.status(404).json({ error: "PDF no disponvel" });
    const { data: signed, error: sErr } = await (supabaseAdmin as any).storage
      .from(DOCS_BUCKET)
      .createSignedUrl(pdfPath, 60);
    if (sErr) return res.status(500).json({ error: sErr.message });
    if (!signed?.signedUrl)
      return res.status(500).json({ error: "Falha ao assinar URL" });
    return res.redirect(signed.signedUrl);
  } catch (e: any) {
    return res.status(500).json({ error: e?.message || "Download error" });
  }
});

// Create basic CONTRACT document draft from simple payload
app.post("/documents", requireAuth, async (req: any, res) => {
  try {
    const authUserId = req.user.id as string;
    // Resolve local user row
    const { data: urow, error: uerr } = await supabaseAdmin
      .from("users")
      .select("id, company_id")
      .eq("user_id", authUserId)
      .maybeSingle();
    if (uerr) return res.status(500).json({ error: uerr.message });
    if (!urow?.company_id)
      return res.status(404).json({ error: "Usu?rio sem company_id" });

    const body = req.body || {};
    let customerId: string | null = body.customer_id || null;
    const leadId: string | null = body.lead_id || null;

    // If no customer_id, attempt to create from lead
    if (!customerId && leadId) {
      try {
        const { data: cust } = await supabaseAdmin
          .from("customers")
          .select("id")
          .eq("lead_id", leadId)
          .maybeSingle();
        customerId = (cust as any)?.id || null;
      } catch {}
      if (!customerId) {
        // fetch lead minimal
        const { data: l } = await supabaseAdmin
          .from("leads")
          .select("id, name, email")
          .eq("id", leadId)
          .maybeSingle();
        const payload: any = {
          company_id: (urow as any).company_id,
          name: (l as any)?.name || "Cliente",
          email: (l as any)?.email || null,
        };
        try {
          // try with lead_id if column exists
          payload.lead_id = leadId;
          const { data: created } = await supabaseAdmin
            .from("customers")
            .insert([payload])
            .select("id")
            .single();
          customerId = (created as any)?.id || null;
        } catch {
          // retry without lead_id
          delete payload.lead_id;
          const { data: created2 } = await supabaseAdmin
            .from("customers")
            .insert([payload])
            .select("id")
            .single();
          customerId = (created2 as any)?.id || null;
        }
      }
    }

    if (!customerId)
      return res
        .status(400)
        .json({ error: "customer_id ou lead_id obrigat?rio" });

    const discountPct = Number(body.discountPct || 0);
    const itemDesc = String(body.item_description || "Item");
    const qty = Number(body.quantity || 1);
    const unitPrice = Number(body.unit_price || 0);
    const subtotal = qty * unitPrice;
    const discount = (Math.max(0, Math.min(100, discountPct)) / 100) * subtotal;
    const total = Math.max(0, subtotal - discount);

    const propId: string | null =
      (body.proposal_id ||
        body.proposta_id ||
        body?.metadata?.proposal_id ||
        null) ??
      null;

    const meta: any = { ...(body.metadata ?? {}) };
    meta.payload = {
      item_description: itemDesc,
      quantity: qty,
      unit_price: unitPrice,
      discountPct,
    };

    const docInsert: any = {
      company_id: (urow as any).company_id,
      doc_type: String(body.doc_type || "CONTRACT"),
      status: "DRAFT",
      customer_id: customerId,
      currency: "BRL",
      metadata: meta,
      proposta_id: propId,
      subtotal,
      discount,
      total,
      created_by: (urow as any).id,
      updated_by: (urow as any).id,
    };

    const { data: doc, error: dErr } = await supabaseAdmin
      .from("documents")
      .insert([docInsert])
      .select("id")
      .single();
    if (dErr) return res.status(500).json({ error: dErr.message });

    const docId = (doc as any).id as string;
    const item = {
      document_id: docId,
      position: 1,
      description: itemDesc,
      quantity: qty,
      unit: body.unit || null,
      unit_price: unitPrice,
      total: total,
    } as any;
    try {
      await supabaseAdmin.from("document_items").insert([item]);
    } catch {}

    return res.status(201).json({ id: docId });
  } catch (e: any) {
    return res
      .status(500)
      .json({ error: e?.message || "Create document error" });
  }
});
